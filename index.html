<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>ü§ñ fakebot</title>
  <style>
    :root{
      /* Page theme vars */
      --pageBg:#0b0f14;
      --pageInk:#e9eef6;
      --pageMuted:#9aa6b2;
      --pageLine:rgba(255,255,255,.09);
      --pagePanel:rgba(255,255,255,.05);
      --pagePanel2:rgba(0,0,0,.20);

      --pageGlowA: rgba(122,162,255,.08);
      --pageGlowB: rgba(182,124,255,.08);
      --pageGlowC: rgba(63,225,139,.06);

      /* Piano theme */
      --accent:#2f6bff;  /* scale fill */
      --good:#3fe18b;    /* root marker */
      --chord:#b67cff;   /* chord marker */

      --keyWhite:#f2f5fb;
      --keyBlack:#161b23;
      --keyBorder:#c9d3e2;
      --keyBlackBorder:#2a3240;

      /* Fixed thin black outline for scale keys */
      --scaleStrokeAlpha: 0.88;
      --scaleStrokeWidth: 2.2;

      --radius:16px;
      --tap:44px;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--pageInk);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      -webkit-font-smoothing: antialiased;
      overflow-x:hidden;
      touch-action: manipulation;
      background: var(--pageBg);
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      z-index:-1;
      background:
        radial-gradient(1200px 800px at 30% 10%, var(--pageGlowA), transparent 55%),
        radial-gradient(900px 600px at 90% 30%, var(--pageGlowB), transparent 55%),
        radial-gradient(1100px 700px at 55% 95%, var(--pageGlowC), transparent 60%),
        linear-gradient(180deg, var(--pageBg), var(--pageBg));
      background-repeat:no-repeat;
    }

    button, input, select, label {font:inherit}
    button { -webkit-tap-highlight-color: transparent; }
    input[type="range"]{width:100%}
    .app{max-width:1100px;margin:0 auto;padding:14px 12px 22px;}

    .header{
      padding:12px 12px;border:1px solid var(--pageLine);border-radius: var(--radius);
      background: var(--pagePanel);box-shadow: var(--shadow);margin-bottom:12px;
    }
    .headerTop{display:flex;align-items:flex-end;justify-content:space-between;gap:10px;flex-wrap:wrap;}
    h1{margin:0;font-size:18px;font-weight:900;letter-spacing:.2px;}
    .sub{margin-top:2px;color:var(--pageMuted);font-size:12px;}
    .statusLine{margin-top:10px;display:flex;flex-wrap:wrap;gap:8px;align-items:center;}
    .pill{
      padding:6px 10px;border:1px solid var(--pageLine);border-radius:999px;
      background: rgba(0,0,0,.18);color: var(--pageMuted);font-size:12px;
      user-select:none;white-space:nowrap;
    }
    .pill strong{color:var(--pageInk);font-weight:900}
    .msg{margin-top:10px;font-size:12px;color: var(--pageMuted);user-select:none;}

    .card{
      border:1px solid var(--pageLine);border-radius: var(--radius);
      background: var(--pagePanel);box-shadow: var(--shadow);
      overflow:hidden;margin-bottom:12px;
    }
    .cardHead{
      display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
      padding:12px 12px;border-bottom:1px solid rgba(255,255,255,.06);
      background: rgba(0,0,0,.12);
    }
    .title{font-size:12px;color:var(--pageMuted);letter-spacing:.2px;user-select:none;}
    .cardBody{padding:12px}

    .controls{display:grid;grid-template-columns: repeat(6, minmax(0,1fr));gap:10px;}
    @media (max-width: 980px){ .controls{grid-template-columns: repeat(3, minmax(0,1fr));} }
    @media (max-width: 520px){ .controls{grid-template-columns: repeat(2, minmax(0,1fr));} }

    .control{
      padding:10px;border-radius:14px;border:1px solid rgba(255,255,255,.08);
      background: var(--pagePanel2);min-width:0;
    }
    .control label{display:block;font-size:11px;color: rgba(154,166,178,.88);margin-bottom:6px;user-select:none;}
    .inline{display:flex;align-items:center;gap:8px;min-width:0;}
    input[type="number"], select{
      width: 98px;min-height: 38px;background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);color: var(--pageInk);
      border-radius: 10px;padding: 8px 8px;outline:none;
    }
    select{width:100%}

    .btn{
      min-height: var(--tap);
      padding: 10px 12px;border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      color: var(--pageInk);cursor:pointer;
      display:inline-flex;align-items:center;justify-content:center;gap:8px;
      transition: transform .06s ease, border-color .15s ease,width .15s ease;
      width:100%;
      user-select:none;
    }
    .btn:active{transform: translateY(1px)}
    .btn.primary{
      border-color: rgba(122,162,255,.45);
      background: linear-gradient(180deg, rgba(122,162,255,.18), rgba(122,162,255,.06));
    }
    .btn.ghost{background: transparent}
    .btn.small{min-height:36px;padding:7px 8px;border-radius:10px;font-size:13px}
    .btn.tiny{min-height:34px;padding:6px 8px;border-radius:10px;font-size:12px}

    .sheet{display:grid;grid-template-columns: repeat(4, minmax(0, 1fr));gap:10px;}
    @media (max-width: 640px){ .sheet{grid-template-columns: repeat(2, minmax(0, 1fr));} }
    .bar{
      position:relative;min-height: 62px;background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.08);border-radius: 14px;
      padding: 12px 10px 10px;cursor:pointer;
      transition: border-color .15s ease, transform .06s ease, background .15s ease;
      overflow:hidden;user-select:none;
    }
    .bar:active{transform: translateY(1px)}
    .bar.active{border-color: rgba(122,162,255,.70);background: rgba(122,162,255,.08);}
    .bar .sym{font-weight:900;letter-spacing:.2px;font-size:16px;line-height:1.15;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding-right:28px;}
    .bar .sym2{margin-top:6px;padding-top:6px;border-top:1px solid rgba(255,255,255,.08);}
    .bar .num{position:absolute;top:10px;right:10px;font-size:12px;color: rgba(154,166,178,.55);}

    .bar .halfHit{
      position:absolute; inset:0;
      display:flex; flex-direction:column;
      pointer-events:none;
    }
    .bar .halfHit button{
      flex:1;background:transparent;border:0;padding:0;margin:0;cursor:pointer;pointer-events:auto;
    }
    .bar .halfHit button:active{background: rgba(122,162,255,.06);}
    .bar .halfHit button:first-child{border-bottom:1px solid rgba(255,255,255,.06);}

    .limitGrid{display:grid;grid-template-columns: repeat(3, minmax(0,1fr));gap:10px;}
    @media (max-width: 820px){ .limitGrid{grid-template-columns: repeat(2, minmax(0,1fr));} }
    @media (max-width: 520px){ .limitGrid{grid-template-columns: 1fr;} }

    .checkRow{display:flex;flex-wrap:wrap;gap:8px;align-items:center;}
    .chip{
      display:inline-flex;align-items:center;gap:8px;padding:10px 10px;border-radius: 14px;
      border:1px solid rgba(255,255,255,.08);background: rgba(0,0,0,.18);
      min-height: 44px;user-select:none;
    }
    .chip input{transform: scale(1.1)}
    .chip span{font-size:13px;color: rgba(233,238,246,.92)}

    .legend{display:flex;gap:10px;flex-wrap:wrap;align-items:center;color: var(--pageMuted);font-size:12px;user-select:none;margin-bottom:10px;}
    .dotLegend{display:inline-flex;align-items:center;gap:6px;}
    .sw{width:10px;height:10px;border-radius:999px;border:1px solid rgba(255,255,255,.15);}
    .sw.scale{background: var(--accent); border-color: rgba(47,107,255,.95)}
    .sw.root{background: var(--good); border-color: rgba(63,225,139,.95)}
    .sw.chord{background: var(--chord); border-color: rgba(182,124,255,.95)}

    .pianoBox{border:1px solid rgba(255,255,255,.10);border-radius: 16px;background: rgba(0,0,0,.18);overflow:hidden;}
    svg{display:block;width:100%;height:auto}
    .hint{margin-top:10px;color: rgba(154,166,178,.85);font-size:12px;line-height:1.2;user-select:none;}

    /* Advanced settings modal */
    .modalBack{
      position:fixed;inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:flex-end;
      justify-content:center;
      padding:14px;
      z-index:9999;
    }
    .modal{
      width:min(760px,100%);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      background: rgba(12,16,22,.96);
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modalHead{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:12px 12px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .modalTitle{font-weight:900;font-size:14px;letter-spacing:.2px;}
    .modalBody{padding:12px}
    .modalRow{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:10px 10px;border:1px solid rgba(255,255,255,.08);
      border-radius:14px;background: rgba(0,0,0,.22);
      margin-bottom:10px;
    }
    .modalRow .name{font-size:13px;color: rgba(233,238,246,.92);font-weight:800}
    .reorderBtns{display:flex;gap:8px}
    .gearBtn{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius: 12px;
      min-height: 38px;
      padding:8px 10px;
      cursor:pointer;
      color: var(--pageInk);
      display:inline-flex;align-items:center;gap:8px;
      user-select:none;
    }
    .splitLine{height:1px;background: rgba(255,255,255,.10);margin:12px 0;}
    .modalSubTitle{font-size:12px;color: var(--pageMuted);margin:0 0 8px 2px;}
    .modalGrid{display:grid;grid-template-columns: 1fr 1fr; gap:10px;}
    @media (max-width: 560px){ .modalGrid{grid-template-columns: 1fr;} }
    .miniCtl{
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      background: rgba(0,0,0,.22);
      padding:10px;
    }
    .miniCtl label{display:block;font-size:11px;color: rgba(154,166,178,.88);margin-bottom:6px;}
    .miniRow{display:flex;gap:8px;align-items:center;}
    .miniRow input[type="range"]{flex:1}
    .miniRow input[type="number"]{width:86px}
  </style>
</head>

<body>
  <div class="app">

    <div class="header">
      <div class="headerTop">
        <div>
          <h1>ü§ñ fakebot</h1>
          <div class="sub">random charts ¬∑ band ¬∑ keyboard display</div>
        </div>

        <div style="min-width:220px; width:min(420px,100%);">
          <button class="btn ghost" id="btnCopy" style="width:32%; display:inline-flex;" title="Copy chart">üìã</button>
          <button class="btn" id="btnDefaults" style="width:32%; display:inline-flex; margin:0 1%;" title="Defaults">‚Ü©Ô∏è</button>
          <button class="btn primary" id="btnPlay" style="width:32%; display:inline-flex; float:right;" title="Play">‚ñ∂Ô∏è</button>
          <div style="clear:both"></div>
        </div>
      </div>

      <div class="statusLine">
        <span class="pill" id="pillLine">‚Äî</span>
        <span class="pill">Bars: <strong id="metaBars">8</strong></span>
        <span class="pill">Tempo: <strong id="metaTempo">140</strong></span>
        <span class="pill">Swing: <strong id="metaSwing">58</strong></span>
        <span class="pill">Chaos: <strong id="metaChaos">35</strong></span>
        <span class="pill" id="metaHalves" style="display:none;">¬Ω-bars: <strong id="metaHalvesVal">0</strong></span>
      </div>

      <div class="msg" id="msg">Tip: tap a bar (or half) to focus the piano + band on that chord (and preview it).</div>
    </div>

    <!-- LEAD SHEET -->
    <section class="card" id="cardLead">
      <div class="cardHead">
        <div class="title">Lead sheet</div>
        <div class="title" id="leadKey">‚Äî</div>
      </div>
      <div class="cardBody">
        <div class="sheet" id="sheet"></div>
      </div>
    </section>

    <!-- PIANO -->
    <section class="card" id="cardPiano">
      <div class="cardHead">
        <div class="title">üéπ</div>
        <div class="title" id="pianoTop">‚Äî</div>
      </div>
      <div class="cardBody">
        <div class="legend">
          <span class="dotLegend"><span class="sw scale"></span>Scale tones</span>
          <span class="dotLegend"><span class="sw root"></span>Root</span>
          <span class="dotLegend"><span class="sw chord"></span>Chord tones</span>
        </div>
        <div class="pianoBox">
          <svg id="pianoSvg" viewBox="0 0 1000 240" preserveAspectRatio="none" aria-label="Piano keyboard"></svg>
        </div>
        <div class="hint" id="pianoHint">‚Äî</div>
      </div>
    </section>

    <!-- Controls -->
    <section class="card" id="cardControls">
      <div class="cardHead">
        <div class="title">Controls</div>
        <button class="gearBtn" id="btnGear" aria-label="Advanced settings" title="Advanced settings">
          ‚öôÔ∏è <span style="font-size:12px;color:var(--pageMuted);">Advanced</span>
        </button>
      </div>

      <div class="cardBody">
        <div class="controls" id="controlsGrid">

          <div class="control" data-ctl="generate">
            <label>Generate</label>
            <div class="inline" style="gap:6px">
              <button class="btn primary tiny" id="btnGenerate" style="flex:1" title="Generate">üé∞</button>
              <button class="btn tiny" id="btnRandomAll" style="flex:1" title="Randomize everything">üé≤</button>
              <button class="btn tiny" id="btnDefaults2" style="flex:1" title="Defaults">‚Ü©Ô∏è</button>
            </div>
          </div>

          <div class="control" data-ctl="songLoader">
            <label>Song shapes (50)</label>
            <select id="songSelect"></select>
            <div class="msg" style="margin:6px 0 0 0;">Original ‚Äústandard-like‚Äù forms (reharm-ish templates), not copied charts.</div>
          </div>

          <div class="control" data-ctl="genre">
            <label>Genre preset</label>
            <select id="genrePreset"></select>
          </div>

          <div class="control" data-ctl="progLogic">
            <label>Progression logic</label>
            <select id="progressionLogic"></select>
            <div class="msg" style="margin:6px 0 0 0;">Biases the generator‚Äôs decisions (not canned progressions).</div>
          </div>

          <div class="control" data-ctl="bars">
            <label>Bars (2‚Äì16)</label>
            <div class="inline">
              <input id="bars" type="range" min="2" max="16" value="8">
              <input id="barsNum" type="number" min="2" max="16" value="8">
            </div>
          </div>

          <div class="control" data-ctl="half">
            <label>2 chords / bar (random bars)</label>
            <div class="checkRow" style="margin-bottom:8px;">
              <label class="chip" style="width:100%;justify-content:space-between;">
                <span>Enable occasional ¬Ω-bars</span>
                <input type="checkbox" id="halfChords">
              </label>
            </div>
            <div class="inline">
              <input id="halfDensity" type="range" min="0" max="100" value="22">
              <input id="halfDensityNum" type="number" min="0" max="100" value="22">
            </div>
            <div class="msg" style="margin:6px 0 0 0;">Density %</div>
          </div>

          <div class="control" data-ctl="tempo">
            <label>Tempo</label>
            <div class="inline">
              <input id="tempo" type="range" min="60" max="220" value="140">
              <input id="tempoNum" type="number" min="40" max="300" value="140">
            </div>
          </div>

          <div class="control" data-ctl="swing">
            <label>Swing</label>
            <div class="inline">
              <input id="swing" type="range" min="50" max="75" value="58">
              <input id="swingNum" type="number" min="50" max="80" value="58">
            </div>
          </div>

          <div class="control" data-ctl="chaos">
            <label>Chaos</label>
            <div class="inline">
              <input id="chaos" type="range" min="0" max="100" value="35">
              <input id="chaosNum" type="number" min="0" max="100" value="35">
            </div>
            <div class="msg" style="margin:6px 0 0 0;">More = weirder roots/qualities/tension + more drift.</div>
          </div>

          <div class="control" data-ctl="rootMode">
            <label>Root mode</label>
            <select id="rootMode">
              <option value="keyed" selected>Keyed</option>
              <option value="drifting">Drifting</option>
              <option value="orbiting">Orbiting</option>
              <option value="freefall">Freefall</option>
            </select>
          </div>

          <div class="control" data-ctl="groove">
            <label>Groove (drums)</label>
            <select id="grooveStyle">
              <option value="swing" selected>Swing ride</option>
              <option value="brushBallad">Brush ballad</option>
              <option value="bossa">Bossa</option>
              <option value="samba">Samba</option>
              <option value="afroCuban">Afro-Cuban</option>
              <option value="funk">Funk</option>
              <option value="disco">Disco</option>
              <option value="rock">Rock</option>
              <option value="shuffle">Shuffle</option>
              <option value="hiphop">Hip-hop</option>
              <option value="house">House</option>
              <option value="techno">Techno</option>
              <option value="dnb">DnB</option>
              <option value="breaks">Breakbeat</option>
              <option value="ambient">Ambient ticks</option>
              <option value="free">Free cymbals</option>
            </select>
          </div>

          <div class="control" data-ctl="compStyle">
            <label>Keys play style</label>
            <select id="compStyle">
              <option value="twoStabs" selected>2 stabs</option>
              <option value="fourComp">4-to-the-bar</option>
              <option value="charleston">Charleston</option>
              <option value="anticipations">Anticipations</option>
              <option value="pushPull">Push / pull</option>
              <option value="sparse">Sparse sync</option>
              <option value="arpeggio">Arp flutter</option>
              <option value="sustain">Sustain pad</option>
              <option value="montuno">Montuno (latin)</option>
              <option value="clav">Clav comp (funk)</option>
              <option value="rockChugs">Rock chugs</option>
              <option value="discoChop">Disco chop</option>
              <option value="neoSoulPush">Neo-soul pushes</option>
              <option value="edmStab">EDM stabs</option>
            </select>
          </div>

          <div class="control" data-ctl="bassPreset">
            <label>Bass sound (minimal)</label>
            <select id="bassPreset">
              <option value="upright" selected>Upright</option>
              <option value="round">Round</option>
              <option value="sub">Sub</option>
              <option value="pluck">Pluck</option>
              <option value="fmBass">FM bass</option>
              <option value="rubber">Rubber</option>
              <option value="acid">Acid</option>
              <option value="reese">Reese</option>
              <option value="squareBass">Square bass</option>
              <option value="wobble">Wobble</option>
              <option value="pickBass">Pick bass</option>
              <option value="muted">Muted</option>
            </select>
          </div>

          <div class="control" data-ctl="keysPreset">
            <label>Keys sound (minimal)</label>
            <select id="keysPreset">
              <option value="ep" selected>EP</option>
              <option value="piano">Piano</option>
              <option value="organ">Organ</option>
              <option value="pad">Pad</option>
              <option value="fm">FM keys</option>
              <option value="chip">Chip</option>
              <option value="bell">Bell</option>
              <option value="glass">Glass</option>
              <option value="pluck2">Pluck 2</option>
              <option value="vibes">Vibes</option>
              <option value="choirPad">Choir pad</option>
              <option value="noisePad">Noise pad</option>
              <option value="guitarish">Guitar-ish</option>
              <option value="clavBright">Clav bright</option>
            </select>
          </div>

          <div class="control" data-ctl="drumsPreset">
            <label>Drums sound (minimal)</label>
            <select id="drumsPreset">
              <option value="jazz" selected>Jazz kit</option>
              <option value="brushes">Brushes</option>
              <option value="tight">Tight</option>
              <option value="rock">Rock kit</option>
              <option value="disco">Disco kit</option>
              <option value="lofi">Lo-fi</option>
              <option value="minimal">Minimal clicks</option>
              <option value="electro">Electro</option>
              <option value="house">House</option>
              <option value="trap">Trap hats</option>
              <option value="perc">Perc kit</option>
              <option value="dnb">DnB kit</option>
              <option value="techno">Techno kit</option>
            </select>
          </div>

          <div class="control" data-ctl="drumsLevel">
            <label>Drums level</label>
            <div class="inline">
              <input id="drumsLevel" type="range" min="0" max="100" value="55">
              <input id="drumsLevelNum" type="number" min="0" max="100" value="55">
            </div>
          </div>

          <!-- Fill + Complexity per instrument -->
          <div class="control" data-ctl="keysFeel">
            <label>Keys: complexity / fills</label>
            <div class="inline" style="margin-bottom:8px;">
              <input id="keysComplex" type="range" min="0" max="100" value="55">
              <input id="keysComplexNum" type="number" min="0" max="100" value="55">
            </div>
            <div class="inline">
              <input id="keysFill" type="range" min="0" max="100" value="30">
              <input id="keysFillNum" type="number" min="0" max="100" value="30">
            </div>
          </div>

          <div class="control" data-ctl="bassFeel">
            <label>Bass: complexity / fills</label>
            <div class="inline" style="margin-bottom:8px;">
              <input id="bassComplex" type="range" min="0" max="100" value="55">
              <input id="bassComplexNum" type="number" min="0" max="100" value="55">
            </div>
            <div class="inline">
              <input id="bassFill" type="range" min="0" max="100" value="25">
              <input id="bassFillNum" type="number" min="0" max="100" value="25">
            </div>
          </div>

          <div class="control" data-ctl="drumsFeel">
            <label>Drums: complexity / fills</label>
            <div class="inline" style="margin-bottom:8px;">
              <input id="drumsComplex" type="range" min="0" max="100" value="65">
              <input id="drumsComplexNum" type="number" min="0" max="100" value="65">
            </div>
            <div class="inline">
              <input id="drumsFill" type="range" min="0" max="100" value="40">
              <input id="drumsFillNum" type="number" min="0" max="100" value="40">
            </div>
          </div>

        </div>
      </div>
    </section>

    <!-- CHORD LIMITERS -->
    <section class="card" id="cardLimiters">
      <div class="cardHead">
        <div class="title">Chord limiters</div>
        <div class="title">üß©</div>
      </div>
      <div class="cardBody">
        <div class="limitGrid">
          <div class="control">
            <label>Core qualities</label>
            <div class="checkRow">
              <label class="chip"><input type="checkbox" id="qMaj7" checked><span>maj7</span></label>
              <label class="chip"><input type="checkbox" id="qMin7" checked><span>m7</span></label>
              <label class="chip"><input type="checkbox" id="qDom7" checked><span>7</span></label>
              <label class="chip"><input type="checkbox" id="qDim7" checked><span>dim7</span></label>
              <label class="chip"><input type="checkbox" id="qHalfDim"><span>√∏7</span></label>
              <label class="chip"><input type="checkbox" id="qSus"><span>sus</span></label>
              <label class="chip"><input type="checkbox" id="qMinMaj"><span>mMaj7</span></label>
            </div>
          </div>

          <div class="control">
            <label>Extensions</label>
            <div class="checkRow">
              <label class="chip"><input type="checkbox" id="x9"><span>9</span></label>
              <label class="chip"><input type="checkbox" id="x11"><span>11</span></label>
              <label class="chip"><input type="checkbox" id="x13"><span>13</span></label>
              <label class="chip"><input type="checkbox" id="x6"><span>6 / 6-9</span></label>
              <label class="chip"><input type="checkbox" id="xAdd9"><span>add9</span></label>
              <label class="chip"><input type="checkbox" id="xSharp11"><span>#11</span></label>
              <label class="chip"><input type="checkbox" id="xMin11"><span>m11</span></label>
            </div>
          </div>

          <div class="control">
            <label>Tension</label>
            <div class="checkRow">
              <label class="chip"><input type="checkbox" id="tAlt"><span>alt dom</span></label>
              <label class="chip"><input type="checkbox" id="tSlash"><span>slash</span></label>
              <label class="chip"><input type="checkbox" id="tChrom"><span>chromatic</span></label>
              <label class="chip"><input type="checkbox" id="tB9"><span>‚ô≠9</span></label>
              <label class="chip"><input type="checkbox" id="tSharp9"><span>#9</span></label>
            </div>
          </div>
        </div>

        <div class="msg" style="margin-top:12px;">Tip: pick limiters first, then Generate üé∞.</div>
      </div>
    </section>

  </div>

  <!-- Advanced Settings Modal -->
  <div class="modalBack" id="advBack" role="dialog" aria-modal="true" aria-label="Advanced settings">
    <div class="modal">
      <div class="modalHead">
        <div class="modalTitle">Advanced settings</div>
        <div class="reorderBtns">
          <button class="btn small" id="btnResetMenu">Reset</button>
          <button class="btn primary small" id="btnCloseAdv">Done</button>
        </div>
      </div>

      <div class="modalBody">
        <div class="msg" style="margin:0 0 10px 0;">Menu order (main sections). Page theme + piano theme live here.</div>
        <div id="orderList"></div>

        <div class="splitLine"></div>

        <div class="modalSubTitle">Themes</div>
        <div class="modalGrid">
          <div class="miniCtl">
            <label>Page theme</label>
            <select id="pageTheme"></select>
          </div>
          <div class="miniCtl">
            <label>Piano theme</label>
            <select id="pianoTheme"></select>
          </div>
          <div class="miniCtl">
            <label>Tone markers</label>
            <select id="markerStyle">
              <option value="dots" selected>Dots</option>
              <option value="rings">Rings</option>
              <option value="triangles">Triangles</option>
              <option value="squares">Squares</option>
            </select>
          </div>
        </div>

        <div class="msg" style="margin-top:10px;">Tip: advanced settings save locally in your browser.</div>
      </div>
    </div>
  </div>

<script>
/* =========================================================
   fakebot ‚Äî SINGLE-FILE BUILD (no missing references)
   - Lead sheet + Piano always render
   - Tap audition works after play/pause
   - Band playback stays synced with UI
   - 50 ‚Äústandard-like‚Äù song shapes (original templates)
   ========================================================= */

/* ---------- Core helpers ---------- */
const NOTE_NAMES = ["C","C#","D","Eb","E","F","F#","G","Ab","A","Bb","B"];
const WHITE_PCS = new Set([0,2,4,5,7,9,11]);
const pc = (n)=>((n%12)+12)%12;
const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
const rint = (a,b)=>Math.floor(a + Math.random()*(b-a+1));
const pick = (arr)=>arr[Math.floor(Math.random()*arr.length)];
const chance = (p)=>Math.random()<p;
const noteName = (p)=>NOTE_NAMES[pc(p)];
function weightedPick(opts){
  const sum = opts.reduce((s,o)=>s+o.w,0);
  let t = Math.random()*sum;
  for (const o of opts){ t -= o.w; if (t<=0) return o.v; }
  return opts[opts.length-1].v;
}

/* ---------- Scales / chords ---------- */
const SCALES = {
  ionian:[0,2,4,5,7,9,11],
  dorian:[0,2,3,5,7,9,10],
  phryg:[0,1,3,5,7,8,10],
  lydian:[0,2,4,6,7,9,11],
  mixo:  [0,2,4,5,7,9,10],
  aeolian:[0,2,3,5,7,8,10],
  locrian:[0,1,3,5,6,8,10],
  melodicMinor:[0,2,3,5,7,9,11],
  lydianDom:[0,2,4,6,7,9,10],
  altered:[0,1,3,4,6,8,10],
};
const CHORDS = {
  maj7:[0,4,7,11],
  maj9:[0,4,7,11,14],
  maj6:[0,4,7,9],
  "6/9":[0,4,7,9,14],
  add9:[0,4,7,14],
  maj9sharp11:[0,4,7,11,14,18],

  min7:[0,3,7,10],
  min9:[0,3,7,10,14],
  min6:[0,3,7,9],
  min11:[0,3,7,10,14,17],

  minMaj7:[0,3,7,11],
  minMaj9:[0,3,7,11,14],

  dom7:[0,4,7,10],
  dom9:[0,4,7,10,14],
  dom11:[0,4,7,10,14,17],
  dom13:[0,4,7,10,14,21],
  dom7b9:[0,4,7,10,13],
  dom7sharp9:[0,4,7,10,15],

  sus:[0,5,7,10],
  "7sus":[0,5,7,10,14],

  halfdim:[0,3,6,10],
  dim7:[0,3,6,9],
};

function chordName(ch){
  const base = `${noteName(ch.root)}${ch.symbol}`;
  return (ch.slash!=null) ? `${base}/${noteName(ch.slash)}` : base;
}
function chordTonesPCs(ch){
  return [...new Set(ch.intervals.map(i=>pc(ch.root+i)))];
}

/* ---------- Chord-local scale selection (context-aware) ---------- */
function candidatesForChord(ch){
  const hasSharp11 = chordTonesPCs(ch).includes(pc(ch.root + 6)) || (ch.symbol||"").includes("#11");
  if (ch.family === "maj") return hasSharp11 ? ["lydian","ionian"] : ["ionian","lydian"];
  if (ch.family === "min") return ["dorian","aeolian","phryg"];
  if (ch.family === "minmaj") return ["melodicMinor","dorian","aeolian"];
  if (ch.family === "dom"){
    const hasSharp11Dom = chordTonesPCs(ch).includes(pc(ch.root+6));
    return hasSharp11Dom ? ["lydianDom","mixo","altered"] : ["mixo","lydianDom","altered"];
  }
  if (ch.family === "sus") return ["mixo","dorian"];
  if (ch.family === "hdim" || ch.family === "dim") return ["locrian"];
  return ["mixo"];
}
function scoreModeForContext(ch, mode, prevCh, nextCh){
  const scale = SCALES[mode] || SCALES.mixo;
  const scalePC = new Set(scale.map(i=>pc(ch.root+i)));
  const ctxPCs = [];
  if (prevCh) ctxPCs.push(...chordTonesPCs(prevCh));
  if (nextCh) ctxPCs.push(...chordTonesPCs(nextCh));
  if (prevCh && prevCh.slash!=null) ctxPCs.push(pc(prevCh.slash));
  if (nextCh && nextCh.slash!=null) ctxPCs.push(pc(nextCh.slash));

  let score = 0;
  for (const p of ctxPCs) if (scalePC.has(p)) score += 2;

  if (mode==="ionian") score += 1.2;
  if (mode==="dorian") score += 1.1;
  if (mode==="mixo") score += 1.0;
  if (mode==="lydian") score += 0.6;
  if (mode==="aeolian") score += 0.6;
  if (mode==="phryg") score += 0.2;
  if (mode==="altered") score += 0.2;
  if (mode==="lydianDom") score += 0.4;
  if (mode==="melodicMinor") score += 0.8;

  const chordPCs = chordTonesPCs(ch);
  if (chordPCs.includes(pc(ch.root+6))){
    if (mode==="lydian" || mode==="lydianDom") score += 2.5;
    if (mode==="ionian" || mode==="mixo") score -= 0.5;
  }
  return score;
}
function chooseChordLocalMode(ch, prevCh, nextCh){
  const cand = candidatesForChord(ch);
  let best = cand[0], bestScore = -1e9;
  for (const m of cand){
    const s = scoreModeForContext(ch, m, prevCh, nextCh);
    if (s > bestScore){ bestScore = s; best = m; }
  }
  return best;
}
function scalePCsForChordLocal(ch, prevCh, nextCh){
  const mode = chooseChordLocalMode(ch, prevCh, nextCh);
  const base = SCALES[mode] || SCALES.mixo;
  const pcsSet = new Set();
  base.forEach(i => pcsSet.add(pc(ch.root + i)));
  chordTonesPCs(ch).forEach(p=>pcsSet.add(p));
  if (ch.slash!=null) pcsSet.add(pc(ch.slash));
  return { pcs:[...pcsSet], mode };
}

/* ---------- Limiters ---------- */
function getChordLimiterState(){
  return {
    qMaj7: document.getElementById("qMaj7").checked,
    qMin7: document.getElementById("qMin7").checked,
    qDom7: document.getElementById("qDom7").checked,
    qDim7: document.getElementById("qDim7").checked,
    qHalfDim: document.getElementById("qHalfDim").checked,
    qSus: document.getElementById("qSus").checked,
    qMinMaj: document.getElementById("qMinMaj").checked,
    x9: document.getElementById("x9").checked,
    x11: document.getElementById("x11").checked,
    x13: document.getElementById("x13").checked,
    x6: document.getElementById("x6").checked,
    xAdd9: document.getElementById("xAdd9").checked,
    xSharp11: document.getElementById("xSharp11").checked,
    xMin11: document.getElementById("xMin11").checked,
    tAlt: document.getElementById("tAlt").checked,
    tSlash: document.getElementById("tSlash").checked,
    tChrom: document.getElementById("tChrom").checked,
    tB9: document.getElementById("tB9").checked,
    tSharp9: document.getElementById("tSharp9").checked,
  };
}
function setChordLimiterState(s){
  for (const k of Object.keys(s)){
    const el = document.getElementById(k);
    if (el && el.type === "checkbox") el.checked = !!s[k];
  }
}
function buildQualityOptions(limit){
  const opts = [];
  if (limit.qMaj7){
    opts.push({v:{symbol:"maj7", family:"maj", key:"maj7", display:"maj7"}, w:22});
    if (limit.x9) opts.push({v:{symbol:"maj9", family:"maj", key:"maj9", display:"maj9"}, w:12});
    if (limit.x6) opts.push({v:{symbol:"6/9", family:"maj", key:"6/9", display:"6/9"}, w:10});
    if (limit.x6) opts.push({v:{symbol:"maj6", family:"maj", key:"maj6", display:"6"}, w:7});
    if (limit.xAdd9) opts.push({v:{symbol:"add9", family:"maj", key:"add9", display:"add9"}, w:7});
    if (limit.xSharp11 || limit.x11) opts.push({v:{symbol:"maj9sharp11", family:"maj", key:"maj9sharp11", display:"maj9(#11)"}, w:7});
  }
  if (limit.qMin7){
    opts.push({v:{symbol:"min7", family:"min", key:"min7", display:"m7"}, w:20});
    if (limit.x9) opts.push({v:{symbol:"min9", family:"min", key:"min9", display:"m9"}, w:12});
    if (limit.x6) opts.push({v:{symbol:"min6", family:"min", key:"min6", display:"m6"}, w:8});
    if (limit.xMin11 || limit.x11) opts.push({v:{symbol:"min11", family:"min", key:"min11", display:"m11"}, w:8});
  }
  if (limit.qDom7){
    opts.push({v:{symbol:"dom7", family:"dom", key:"dom7", display:"7"}, w:22});
    if (limit.x9) opts.push({v:{symbol:"dom9", family:"dom", key:"dom9", display:"9"}, w:14});
    if (limit.x11) opts.push({v:{symbol:"dom11", family:"dom", key:"dom11", display:"11"}, w:9});
    if (limit.x13) opts.push({v:{symbol:"dom13", family:"dom", key:"dom13", display:"13"}, w:12});
    if (limit.tB9) opts.push({v:{symbol:"dom7b9", family:"dom", key:"dom7b9", display:"7(b9)"}, w:7});
    if (limit.tSharp9) opts.push({v:{symbol:"dom7sharp9", family:"dom", key:"dom7sharp9", display:"7(#9)"}, w:7});
  }
  if (limit.qMinMaj){
    opts.push({v:{symbol:"minMaj7", family:"minmaj", key:"minMaj7", display:"mMaj7"}, w:7});
    if (limit.x9) opts.push({v:{symbol:"minMaj9", family:"minmaj", key:"minMaj9", display:"mMaj9"}, w:5});
  }
  if (limit.qHalfDim) opts.push({v:{symbol:"halfdim", family:"hdim", key:"halfdim", display:"√∏7"}, w:10});
  if (limit.qDim7)    opts.push({v:{symbol:"dim7", family:"dim", key:"dim7", display:"dim7"}, w:8});
  if (limit.qSus){
    opts.push({v:{symbol:"sus", family:"sus", key:"sus", display:"sus"}, w:6});
    if (limit.x9) opts.push({v:{symbol:"7sus", family:"sus", key:"7sus", display:"7sus"}, w:6});
  }
  if (!opts.length) opts.push({v:{symbol:"dom7", family:"dom", key:"dom7", display:"7"}, w:1});
  return opts;
}

/* ---------- Progression logic ---------- */
const DEG = { I:0, ii:2, iii:4, IV:5, V:7, VI:9, vii:11, bVII:10, bVI:8, bIII:3, bII:1, i:0 };
const FUNCTION_CELLS = [
  ["ii","V","I","I"],
  ["I","VI","ii","V"],
  ["iii","VI","ii","V"],
  ["I","IV","bVII","I"],
  ["i","bVI","ii","V"],
];
function degreeToRoot(deg, baseRoot){ return pc(baseRoot + (DEG[deg] ?? rint(0,11))); }

function macroToWeights(chaos){
  const c = clamp(chaos,0,100)/100;
  return {
    keyStability: Math.round(85 - c*75),
    functional:   Math.round(80 - c*70),
    rootChaos:    Math.round(15 + c*80),
    qualityChaos: Math.round(15 + c*75),
    tension:      Math.round(10 + c*80),
    memoryKill:   Math.round(40 + c*50),
  };
}
function pickKeyMode(chaos){
  const c = clamp(chaos,0,100)/100;
  return weightedPick([
    {v:"ionian", w: 55 - c*15},
    {v:"dorian", w: 16 + c*10},
    {v:"mixo",   w: 16 + c*10},
    {v:"lydian", w:  7 + c*8},
    {v:"aeolian",w:  5 + c*6},
    {v:"locrian",w:  1 + c*5},
  ]);
}

function makeLogicCtx({keyRoot, keyMode, orbitRoot, prevRoot, barIndex, halfIndex, chaos, weights}){
  const c = clamp(chaos,0,100)/100;
  return { keyRoot, keyMode, orbitRoot, prevRoot, barIndex, halfIndex, chaos, c, weights };
}
function logic_chooseFunctionalRoot(ctx, baseRoot){
  const cell = pick(FUNCTION_CELLS);
  const idx = ctx.barIndex % 4;
  const deg = cell[idx] || "I";
  return degreeToRoot(deg, baseRoot);
}
function logic_chooseRockRoot(ctx, baseRoot){
  const diat = SCALES.ionian;
  const pool = [...diat.map(i=>pc(baseRoot+i)), pc(baseRoot+DEG.bVII), pc(baseRoot+DEG.bVI)];
  const prev = ctx.prevRoot ?? baseRoot;
  const scored = pool.map(r=>{
    const dist = Math.min(pc(r-prev), pc(prev-r));
    const fifthish = (pc(r-prev)===7 || pc(prev-r)===7) ? 0.6 : 1.0;
    return { r, w: (1.2/(1+dist)) * fifthish };
  });
  return weightedPick(scored.map(o=>({v:o.r, w:o.w})));
}
function logic_chooseDiscoRoot(ctx, baseRoot){
  const cell = ["I","VI","ii","V"];
  const deg = cell[ctx.barIndex % 4];
  if (chance(0.15 + ctx.c*0.15)) return logic_chooseRockRoot(ctx, baseRoot);
  return degreeToRoot(deg, baseRoot);
}
function logic_chooseBluesRoot(ctx, baseRoot){
  const pos = ctx.barIndex % 12;
  let deg = "I";
  if (pos>=4 && pos<=5) deg = "IV";
  if (pos===7) deg = "IV";
  if (pos===8) deg = "V";
  if (pos===9) deg = "IV";
  if (pos===11) deg = chance(0.55) ? "V" : "bVII";
  let r = degreeToRoot(deg, baseRoot);
  if (chance(0.18 + ctx.c*0.25)) r = pc(r + (chance(.5)?1:-1));
  return r;
}
function logic_chooseJazzFunctionalRoot(ctx, baseRoot){
  const useFunc = chance(clamp(ctx.weights.functional,0,100)/100 * (1 - ctx.c*0.55));
  if (useFunc && ctx.halfIndex===0){
    const r = logic_chooseFunctionalRoot(ctx, baseRoot);
    if (chance(0.18 + ctx.c*0.35)) return pc(r + pick([1,2,11]));
    return r;
  }
  const prev = ctx.prevRoot ?? baseRoot;
  const moves = [
    {v: pc(prev+7), w: 1.6},
    {v: pc(prev-7), w: 0.9},
    {v: pc(prev+2), w: 0.8},
    {v: pc(prev-2), w: 0.8},
    {v: pc(prev+1), w: 0.7 + ctx.c*0.8},
    {v: pc(prev-1), w: 0.7 + ctx.c*0.8},
  ];
  return weightedPick(moves);
}
function logic_chooseNeoSoulRoot(ctx, baseRoot){
  const prev = ctx.prevRoot ?? baseRoot;
  const pool = [
    {v: pc(prev+1), w: 1.5},{v: pc(prev-1), w: 1.5},
    {v: pc(prev+3), w: 1.1},{v: pc(prev-3), w: 1.1},
    {v: pc(prev+6), w: 0.9},{v: pc(prev-6), w: 0.9},
    {v: logic_chooseFunctionalRoot(ctx, baseRoot), w: 1.0},
  ];
  return weightedPick(pool);
}
function logic_chooseFusionRoot(ctx, baseRoot){
  const prev = ctx.prevRoot ?? baseRoot;
  const pool = [
    {v: pc(prev+2), w: 1.3},{v: pc(prev-2), w: 1.3},
    {v: pc(prev+5), w: 0.9},{v: pc(prev-5), w: 0.9},
    {v: pc(prev+1), w: 0.9 + ctx.c*0.8},{v: pc(prev-1), w: 0.9 + ctx.c*0.8},
    {v: logic_chooseJazzFunctionalRoot(ctx, baseRoot), w: 1.1},
  ];
  return weightedPick(pool);
}

/* ---------- Progression logic presets for weights ---------- */
const PROGRESSION_LOGICS = {
  none: { name:"None (fully random)", apply:(w)=>({...w}) },
  jazzFunctional: { name:"Jazz: functional gravity", apply:(w,chaos)=>{
    const c=clamp(chaos,0,100)/100;
    return {...w, functional:clamp(w.functional+18,0,100), keyStability:clamp(w.keyStability+10,0,100),
      rootChaos:clamp(w.rootChaos-10,0,100), tension:clamp(w.tension+(8+10*c),0,100), qualityChaos:clamp(w.qualityChaos+6,0,100)};
  }},
  jazzModal: { name:"Jazz: modal centers", apply:(w,chaos)=>{
    const c=clamp(chaos,0,100)/100;
    return {...w, functional:clamp(w.functional-18,0,100), keyStability:clamp(w.keyStability+12,0,100),
      rootChaos:clamp(w.rootChaos-10,0,100), tension:clamp(w.tension+(3+8*c),0,100), qualityChaos:clamp(w.qualityChaos+6,0,100)};
  }},
  latinTurns: { name:"Latin: turnarounds + cycles", apply:(w,chaos)=>{
    const c=clamp(chaos,0,100)/100;
    return {...w, functional:clamp(w.functional+10,0,100), keyStability:clamp(w.keyStability+8,0,100),
      rootChaos:clamp(w.rootChaos-6,0,100), tension:clamp(w.tension+(10+6*c),0,100), qualityChaos:clamp(w.qualityChaos+6,0,100)};
  }},
  bluesLogic: { name:"Blues: tension & release", apply:(w,chaos)=>{
    const c=clamp(chaos,0,100)/100;
    return {...w, functional:clamp(w.functional+12,0,100), keyStability:clamp(w.keyStability+18,0,100),
      rootChaos:clamp(w.rootChaos-16,0,100), tension:clamp(w.tension+(6+8*c),0,100), qualityChaos:clamp(w.qualityChaos-4,0,100)};
  }},
  rockLogic: { name:"Rock: diatonic + borrowed", apply:(w,chaos)=>{
    const c=clamp(chaos,0,100)/100;
    return {...w, functional:clamp(w.functional-8,0,100), keyStability:clamp(w.keyStability+20,0,100),
      rootChaos:clamp(w.rootChaos-10,0,100), tension:clamp(w.tension+(2+6*c),0,100), qualityChaos:clamp(w.qualityChaos+2,0,100)};
  }},
  discoLogic: { name:"Disco: bright loops", apply:(w,chaos)=>{
    const c=clamp(chaos,0,100)/100;
    return {...w, functional:clamp(w.functional+2,0,100), keyStability:clamp(w.keyStability+18,0,100),
      rootChaos:clamp(w.rootChaos-12,0,100), tension:clamp(w.tension+(4+6*c),0,100), qualityChaos:clamp(w.qualityChaos+6,0,100)};
  }},
  neoSoulLogic: { name:"Neo-Soul: slippery voiceleading", apply:(w,chaos)=>{
    const c=clamp(chaos,0,100)/100;
    return {...w, functional:clamp(w.functional-10,0,100), keyStability:clamp(w.keyStability+10,0,100),
      rootChaos:clamp(w.rootChaos+6,0,100), tension:clamp(w.tension+(8+10*c),0,100), qualityChaos:clamp(w.qualityChaos+10,0,100)};
  }},
  fusionLogic: { name:"Fusion: planing + side-slips", apply:(w,chaos)=>{
    const c=clamp(chaos,0,100)/100;
    return {...w, functional:clamp(w.functional+6,0,100), keyStability:clamp(w.keyStability+6,0,100),
      rootChaos:clamp(w.rootChaos+10,0,100), tension:clamp(w.tension+(10+12*c),0,100), qualityChaos:clamp(w.qualityChaos+12,0,100)};
  }},
  edmLogic: { name:"EDM: loop-centric", apply:(w,chaos)=>{
    const c=clamp(chaos,0,100)/100;
    return {...w, functional:clamp(w.functional-18,0,100), keyStability:clamp(w.keyStability+26,0,100),
      rootChaos:clamp(w.rootChaos-18,0,100), tension:clamp(w.tension-2+6*c,0,100), qualityChaos:clamp(w.qualityChaos-8+10*c,0,100),
      memoryKill:clamp(w.memoryKill+12,0,100)};
  }},
};

/* ---------- Generator ---------- */
function genChartBars({bars, chaos, rootMode, weights, limiter, halfEnabled, halfDensity, progressionLogic}){
  let keyRoot = rint(0,11);
  let keyMode = pickKeyMode(chaos);
  let orbitRoot = keyRoot;
  const qualityPool = buildQualityOptions(limiter);

  const density = clamp(halfDensity,0,100)/100;
  const barSplit = [];
  for (let i=0;i<bars;i++){
    if (!halfEnabled) barSplit.push(false);
    else barSplit.push(chance((i===0 ? density*0.6 : density)));
  }
  const halvesCount = barSplit.filter(Boolean).length;

  const slotPlan = [];
  for (let b=0;b<bars;b++){
    if (!barSplit[b]) slotPlan.push({barIndex:b, halfIndex:0, beats:4});
    else { slotPlan.push({barIndex:b, halfIndex:0, beats:2}); slotPlan.push({barIndex:b, halfIndex:1, beats:2}); }
  }

  const memory = { lastRoots:[], lastQuals:[] };
  function remember(root, qualKey){
    memory.lastRoots.unshift(root); if(memory.lastRoots.length>7) memory.lastRoots.pop();
    memory.lastQuals.unshift(qualKey); if(memory.lastQuals.length>7) memory.lastQuals.pop();
  }
  function memoryBlocks(root, qualKey){
    const kill = clamp(weights.memoryKill,0,100)/100;
    if (kill <= 0.05) return false;
    const blockRoot = memory.lastRoots.includes(root) && chance(kill*0.85);
    const blockQual = memory.lastQuals.includes(qualKey) && chance(kill*0.65);
    return blockRoot || blockQual;
  }
  function chooseQuality(){
    const qC = clamp(weights.qualityChaos,0,100)/100;
    const tweaked = qualityPool.map(o=>{
      const boost = (chance(qC*0.55) ? (1 + Math.random()*0.35) : 1);
      return {v:o.v, w:o.w*boost};
    });
    return weightedPick(tweaked);
  }

  function chooseNextRoot(prevRoot, meta){
    const c = clamp(weights.rootChaos,0,100)/100;
    let cling = clamp(clamp(weights.keyStability,0,100)/100 * (1 - (chaos/100)*0.65), 0, 1);

    if (rootMode === "keyed") cling = Math.max(cling, 0.78);
    if (rootMode === "freefall") cling = Math.min(cling, 0.10);

    if (rootMode === "drifting" && chance((chaos/100)*0.25)){
      keyRoot = pc(keyRoot + pick([1,2,3,5,7,10,11]) * (chance(.5)?1:-1));
      keyMode = pickKeyMode(chaos);
    }
    if (rootMode === "orbiting" && chance((chaos/100)*0.18)){
      orbitRoot = pc(orbitRoot + pick([2,3,5,7,9,10]) * (chance(.5)?1:-1));
    }
    const base = (rootMode==="orbiting") ? orbitRoot : keyRoot;

    const ctx = makeLogicCtx({keyRoot, keyMode, orbitRoot, prevRoot, barIndex: meta.barIndex, halfIndex: meta.halfIndex, chaos, weights});
    const logicId = progressionLogic || "none";
    if (logicId !== "none"){
      if (logicId==="jazzFunctional") return logic_chooseJazzFunctionalRoot(ctx, base);
      if (logicId==="jazzModal") return chance(0.75) ? pc(base + pick(SCALES.dorian)) : logic_chooseJazzFunctionalRoot(ctx, base);
      if (logicId==="latinTurns") return chance(0.65) ? logic_chooseFunctionalRoot(ctx, base) : logic_chooseJazzFunctionalRoot(ctx, base);
      if (logicId==="bluesLogic") return logic_chooseBluesRoot(ctx, base);
      if (logicId==="rockLogic") return logic_chooseRockRoot(ctx, base);
      if (logicId==="discoLogic") return logic_chooseDiscoRoot(ctx, base);
      if (logicId==="neoSoulLogic") return logic_chooseNeoSoulRoot(ctx, base);
      if (logicId==="fusionLogic") return logic_chooseFusionRoot(ctx, base);
      if (logicId==="edmLogic") return chance(0.72) ? logic_chooseDiscoRoot(ctx, base) : logic_chooseRockRoot(ctx, base);
    }

    // fallback original random behavior
    const funcBias = clamp(weights.functional,0,100)/100;
    const useFunctional = chance(funcBias * (1 - (chaos/100)*0.55));
    const isBarStart = (meta.halfIndex===0);
    if (useFunctional && isBarStart && (meta.barIndex % 4 === 0) && limiter.tChrom){
      return logic_chooseFunctionalRoot(ctx, base);
    }

    const jumpsSane = [2,5,7,10,3,4,9,8,1,11];
    const jumpsWild = [0,1,2,3,4,5,6,7,8,9,10,11];
    const anchor = chance(cling);

    if (anchor){
      const scale = SCALES[keyMode] || SCALES.ionian;
      let target = pc(base + pick(scale));
      if (limiter.tChrom && chance(c*0.25)) target = pc(target + (chance(.5)?1:-1));
      return target;
    } else {
      if (prevRoot == null) return rint(0,11);
      const pool = chance(c) ? jumpsWild : jumpsSane;
      const step = pick(pool);
      if (pool !== jumpsWild || chance(0.6)) return pc(prevRoot + step * (chance(.5)?1:-1));
      return rint(0,11);
    }
  }

  const slots = [];
  let prevRoot = null;

  for (let i=0;i<slotPlan.length;i++){
    const meta = slotPlan[i];

    let root = chooseNextRoot(prevRoot, meta);
    let q = chooseQuality();

    let guard=0;
    while (memoryBlocks(root, q.key) && guard<8){
      root = chooseNextRoot(prevRoot, meta);
      q = chooseQuality();
      guard++;
    }

    let intervals = (CHORDS[q.symbol] || CHORDS.dom7).slice();
    let label = q.display;

    const tC = clamp(weights.tension,0,100)/100;
    const canAlt = limiter.tAlt && (q.family === "dom") && chance(tC*0.55) && chance((chaos/100)*0.75);
    if (canAlt){
      label = (label === "7" ? "7alt" : (label === "9" ? "9alt" : label + "alt"));
      if (!intervals.includes(14)) intervals.push(14);
      if (chance(0.55)) intervals.push(13);
      if (chance(0.35)) intervals.push(15);
      if (chance(0.35)) intervals.push(18);
    }

    let slash = null;
    if (limiter.tSlash && rootMode !== "keyed"){
      const slashChance = clamp((chaos/100)*0.30, 0, 0.30);
      if (chance(slashChance)){
        slash = pc(root + pick([2,5,7,9,10]) * (chance(.5)?1:-1));
        if (slash === root) slash = pc(root+7);
      }
    }

    slots.push({ root, family:q.family, symbol:label, intervals, slash, meta });
    remember(root, q.key);
    prevRoot = root;
  }

  const barsOut = [];
  for (let b=0;b<bars;b++){
    const s = slots.filter(x=>x.meta.barIndex===b).sort((a,b2)=>a.meta.halfIndex-b2.meta.halfIndex);
    barsOut.push({
      chords: s.map(x=>({root:x.root,family:x.family,symbol:x.symbol,intervals:x.intervals,slash:x.slash})),
      split: barSplit[b] && s.length===2
    });
  }

  const showKey = !(rootMode === "freefall" || clamp(weights.keyStability,0,100) < 25);
  return { bars: barsOut, keyRoot, keyMode, showKey, halvesCount };
}

/* ---------- Themes ---------- */
const PAGE_THEMES = {
  obsidian: { name:"Obsidian (default)", bg:"#0b0f14", a:"rgba(122,162,255,.08)", b:"rgba(182,124,255,.08)", c:"rgba(63,225,139,.05)",
    ink:"#e9eef6", muted:"#9aa6b2", panel:"rgba(255,255,255,.05)", panel2:"rgba(0,0,0,.20)", line:"rgba(255,255,255,.09)" },
  midnight: { name:"Midnight", bg:"#060812", a:"rgba(0,183,255,.08)", b:"rgba(255,77,255,.07)", c:"rgba(255,255,255,.03)",
    ink:"#eef3ff", muted:"#9aa6b2", panel:"rgba(255,255,255,.045)", panel2:"rgba(0,0,0,.22)", line:"rgba(255,255,255,.085)" },
  parchment:{ name:"Parchment", bg:"#f4f1ea", a:"rgba(47,107,255,.10)", b:"rgba(182,124,255,.10)", c:"rgba(63,225,139,.06)",
    ink:"#1b2230", muted:"#4b5566", panel:"rgba(0,0,0,.04)", panel2:"rgba(0,0,0,.06)", line:"rgba(0,0,0,.12)" },
  terminal: { name:"Terminal", bg:"#020604", a:"rgba(0,255,154,.10)", b:"rgba(0,183,255,.06)", c:"rgba(255,255,255,.03)",
    ink:"#c9ffe8", muted:"#7ad4b0", panel:"rgba(0,255,154,.04)", panel2:"rgba(0,0,0,.32)", line:"rgba(0,255,154,.10)" },
  sunset: { name:"Sunset", bg:"#0a0610", a:"rgba(255,120,80,.10)", b:"rgba(255,77,255,.08)", c:"rgba(122,162,255,.07)",
    ink:"#f6efff", muted:"#b8a7c6", panel:"rgba(255,255,255,.05)", panel2:"rgba(0,0,0,.22)", line:"rgba(255,255,255,.09)" },
};
function applyPageTheme(themeId){
  const t = PAGE_THEMES[themeId] || PAGE_THEMES.obsidian;
  document.documentElement.style.setProperty("--pageBg", t.bg);
  document.documentElement.style.setProperty("--pageInk", t.ink);
  document.documentElement.style.setProperty("--pageMuted", t.muted);
  document.documentElement.style.setProperty("--pagePanel", t.panel);
  document.documentElement.style.setProperty("--pagePanel2", t.panel2);
  document.documentElement.style.setProperty("--pageLine", t.line);
  document.documentElement.style.setProperty("--pageGlowA", t.a);
  document.documentElement.style.setProperty("--pageGlowB", t.b);
  document.documentElement.style.setProperty("--pageGlowC", t.c);
  state.pageTheme = themeId;
  try{ localStorage.setItem("fm_page_theme", themeId); }catch{}
}

const PIANO_THEMES = {
  classic:{ name:"Classic", vars:{ "--accent":"#2f6bff","--good":"#3fe18b","--chord":"#b67cff","--keyWhite":"#f2f5fb","--keyBlack":"#161b23","--keyBorder":"#c9d3e2","--keyBlackBorder":"#2a3240" } },
  neon:{ name:"Neon", vars:{ "--accent":"#00b7ff","--good":"#00ff9a","--chord":"#ff4dff","--keyWhite":"#e9f7ff","--keyBlack":"#0b0f14","--keyBorder":"rgba(233,247,255,.45)","--keyBlackBorder":"rgba(255,255,255,.16)" } },
  mono:{ name:"Mono", vars:{ "--accent":"#d7dde6","--good":"#ffffff","--chord":"#b9c2cf","--keyWhite":"#f5f7fb","--keyBlack":"#0f131a","--keyBorder":"#cfd6e2","--keyBlackBorder":"#2a3240" } },
  pastel:{ name:"Pastel", vars:{ "--accent":"#7aa2ff","--good":"#7fffd4","--chord":"#ffb3e6","--keyWhite":"#f7fbff","--keyBlack":"#141826","--keyBorder":"rgba(255,255,255,.25)","--keyBlackBorder":"rgba(255,255,255,.12)" } },
};
function applyPianoTheme(id){
  const t = PIANO_THEMES[id] || PIANO_THEMES.classic;
  for (const k of Object.keys(t.vars)) document.documentElement.style.setProperty(k, t.vars[k]);
  state.pianoTheme = id;
  try{ localStorage.setItem("fm_piano_theme", id); }catch{}
}

/* ---------- UI refs ---------- */
const els = {
  pillLine: document.getElementById("pillLine"),
  leadKey: document.getElementById("leadKey"),
  metaBars: document.getElementById("metaBars"),
  metaTempo: document.getElementById("metaTempo"),
  metaSwing: document.getElementById("metaSwing"),
  metaChaos: document.getElementById("metaChaos"),
  metaHalves: document.getElementById("metaHalves"),
  metaHalvesVal: document.getElementById("metaHalvesVal"),
  msg: document.getElementById("msg"),

  sheet: document.getElementById("sheet"),
  pianoSvg: document.getElementById("pianoSvg"),
  pianoTop: document.getElementById("pianoTop"),
  pianoHint: document.getElementById("pianoHint"),

  btnGenerate: document.getElementById("btnGenerate"),
  btnRandomAll: document.getElementById("btnRandomAll"),
  btnCopy: document.getElementById("btnCopy"),
  btnPlay: document.getElementById("btnPlay"),
  btnDefaults: document.getElementById("btnDefaults"),
  btnDefaults2: document.getElementById("btnDefaults2"),

  songSelect: document.getElementById("songSelect"),
  genrePreset: document.getElementById("genrePreset"),
  progressionLogic: document.getElementById("progressionLogic"),

  bars: document.getElementById("bars"),
  barsNum: document.getElementById("barsNum"),
  halfChords: document.getElementById("halfChords"),
  halfDensity: document.getElementById("halfDensity"),
  halfDensityNum: document.getElementById("halfDensityNum"),
  compStyle: document.getElementById("compStyle"),

  tempo: document.getElementById("tempo"),
  tempoNum: document.getElementById("tempoNum"),
  swing: document.getElementById("swing"),
  swingNum: document.getElementById("swingNum"),
  chaos: document.getElementById("chaos"),
  chaosNum: document.getElementById("chaosNum"),
  rootMode: document.getElementById("rootMode"),

  grooveStyle: document.getElementById("grooveStyle"),
  bassPreset: document.getElementById("bassPreset"),
  keysPreset: document.getElementById("keysPreset"),
  drumsPreset: document.getElementById("drumsPreset"),
  drumsLevel: document.getElementById("drumsLevel"),
  drumsLevelNum: document.getElementById("drumsLevelNum"),

  keysComplex: document.getElementById("keysComplex"),
  keysComplexNum: document.getElementById("keysComplexNum"),
  keysFill: document.getElementById("keysFill"),
  keysFillNum: document.getElementById("keysFillNum"),

  bassComplex: document.getElementById("bassComplex"),
  bassComplexNum: document.getElementById("bassComplexNum"),
  bassFill: document.getElementById("bassFill"),
  bassFillNum: document.getElementById("bassFillNum"),

  drumsComplex: document.getElementById("drumsComplex"),
  drumsComplexNum: document.getElementById("drumsComplexNum"),
  drumsFill: document.getElementById("drumsFill"),
  drumsFillNum: document.getElementById("drumsFillNum"),

  btnGear: document.getElementById("btnGear"),
  advBack: document.getElementById("advBack"),
  orderList: document.getElementById("orderList"),
  btnCloseAdv: document.getElementById("btnCloseAdv"),
  btnResetMenu: document.getElementById("btnResetMenu"),

  pageTheme: document.getElementById("pageTheme"),
  pianoTheme: document.getElementById("pianoTheme"),
  markerStyle: document.getElementById("markerStyle"),
};

/* ---------- Defaults/state ---------- */
const DEFAULTS = {
  bars: 8,
  halfEnabled: true,
  halfDensity: 22,
  tempo: 140,
  swing: 58,
  chaos: 35,
  rootMode: "keyed",

  progressionLogic: "jazzFunctional",
  genrePreset: "jazzSwing",

  grooveStyle: "swing",
  compStyle: "fourComp",

  bassPreset: "upright",
  keysPreset: "piano",
  drumsPreset: "jazz",
  drumsLevel: 55,

  keysComplex: 55,
  keysFill: 30,
  bassComplex: 55,
  bassFill: 25,
  drumsComplex: 65,
  drumsFill: 40,

  limiter: {
    qMaj7:true, qMin7:true, qDom7:true, qDim7:true,
    qHalfDim:false, qSus:false, qMinMaj:false,
    x9:false, x11:false, x13:false, x6:false, xAdd9:false, xSharp11:false, xMin11:false,
    tAlt:false, tSlash:false, tChrom:false, tB9:false, tSharp9:false,
  },

  pageTheme: "obsidian",
  pianoTheme: "neon",
  markerStyle: "dots",
};

let state = {
  bars: DEFAULTS.bars,
  halfEnabled: DEFAULTS.halfEnabled,
  halfDensity: DEFAULTS.halfDensity,
  tempo: DEFAULTS.tempo,
  swing: DEFAULTS.swing,
  chaos: DEFAULTS.chaos,
  rootMode: DEFAULTS.rootMode,

  progressionLogic: DEFAULTS.progressionLogic,
  genrePreset: DEFAULTS.genrePreset,

  grooveStyle: DEFAULTS.grooveStyle,
  compStyle: DEFAULTS.compStyle,

  bassPreset: DEFAULTS.bassPreset,
  keysPreset: DEFAULTS.keysPreset,
  drumsPreset: DEFAULTS.drumsPreset,
  drumsLevel: DEFAULTS.drumsLevel,

  keysComplex: DEFAULTS.keysComplex,
  keysFill: DEFAULTS.keysFill,
  bassComplex: DEFAULTS.bassComplex,
  bassFill: DEFAULTS.bassFill,
  drumsComplex: DEFAULTS.drumsComplex,
  drumsFill: DEFAULTS.drumsFill,

  weights: macroToWeights(DEFAULTS.chaos),
  limiter: getChordLimiterState(),
  chartBars: [],

  keyRoot: 0,
  keyMode: "ionian",
  showKey: true,

  activeBar: 0,
  activeHalf: 0,

  pageTheme: DEFAULTS.pageTheme,
  pianoTheme: DEFAULTS.pianoTheme,
  markerStyle: DEFAULTS.markerStyle,

  fillShapeKeys:"pyramid",
  fillShapeBass:"pulse2",
  fillShapeDrums:"stutter",
};

/* ---------- Genre presets (lots) ---------- */
const GENRE_PRESETS = {
  jazzSwing:{ name:"Jazz Swing (default)", tempo:[120,180], swing:[58,66], groove:"swing", comp:"fourComp",
    bass:"upright", keys:"piano", drums:"jazz", kC:55,kF:30,bC:55,bF:25,dC:65,dF:40, halfOn:true, halfDen:[15,35], logic:"jazzFunctional" },
  bebop:{ name:"Bebop Burner", tempo:[200,260], swing:[60,70], groove:"swing", comp:"fourComp",
    bass:"upright", keys:"ep", drums:"jazz", kC:75,kF:35,bC:75,bF:25,dC:80,dF:50, halfOn:true, halfDen:[30,65], logic:"jazzFunctional" },
  hardBop:{ name:"Hard Bop / Blue Note", tempo:[140,210], swing:[58,66], groove:"swing", comp:"pushPull",
    bass:"round", keys:"organ", drums:"jazz", kC:65,kF:35,bC:65,bF:30,dC:70,dF:45, halfOn:true, halfDen:[20,50], logic:"jazzFunctional" },
  cool:{ name:"Cool / West Coast", tempo:[110,150], swing:[55,62], groove:"brushBallad", comp:"sparse",
    bass:"round", keys:"ep", drums:"brushes", kC:45,kF:20,bC:45,bF:15,dC:45,dF:20, halfOn:false, halfDen:[0,25], logic:"jazzModal" },
  balladJazz:{ name:"Jazz Ballad", tempo:[60,95], swing:[52,58], groove:"brushBallad", comp:"sustain",
    bass:"upright", keys:"pad", drums:"brushes", kC:35,kF:15,bC:35,bF:10,dC:35,dF:18, halfOn:false, halfDen:[0,20], logic:"jazzModal" },
  modalJazz:{ name:"Modal / Spiritual", tempo:[90,140], swing:[52,60], groove:"free", comp:"sustain",
    bass:"round", keys:"pad", drums:"jazz", kC:50,kF:25,bC:50,bF:20,dC:60,dF:45, halfOn:true, halfDen:[10,30], logic:"jazzModal" },

  latinBossa:{ name:"Bossa Nova", tempo:[120,160], swing:[50,54], groove:"bossa", comp:"montuno",
    bass:"round", keys:"vibes", drums:"perc", kC:70,kF:45,bC:65,bF:35,dC:75,dF:55, halfOn:true, halfDen:[30,65], logic:"latinTurns" },
  latinSamba:{ name:"Samba", tempo:[160,210], swing:[50,54], groove:"samba", comp:"montuno",
    bass:"round", keys:"vibes", drums:"perc", kC:80,kF:55,bC:75,bF:45,dC:85,dF:60, halfOn:true, halfDen:[35,70], logic:"latinTurns" },
  afroCuban:{ name:"Afro-Cuban", tempo:[120,190], swing:[50,54], groove:"afroCuban", comp:"montuno",
    bass:"round", keys:"clavBright", drums:"perc", kC:75,kF:55,bC:70,bF:45,dC:85,dF:65, halfOn:true, halfDen:[40,75], logic:"latinTurns" },
  latinBolero:{ name:"Bolero", tempo:[80,115], swing:[50,54], groove:"bossa", comp:"sustain",
    bass:"round", keys:"piano", drums:"perc", kC:40,kF:18,bC:40,bF:15,dC:45,dF:25, halfOn:false, halfDen:[0,25], logic:"latinTurns" },

  funk:{ name:"Funk", tempo:[90,120], swing:[50,56], groove:"funk", comp:"clav",
    bass:"fmBass", keys:"clavBright", drums:"tight", kC:75,kF:55,bC:80,bF:45,dC:80,dF:60, halfOn:true, halfDen:[10,35], logic:"neoSoulLogic" },
  disco:{ name:"Disco", tempo:[112,128], swing:[50,54], groove:"disco", comp:"discoChop",
    bass:"squareBass", keys:"organ", drums:"house", kC:55,kF:35,bC:60,bF:25,dC:60,dF:35, halfOn:true, halfDen:[8,22], logic:"discoLogic" },
  rockClassic:{ name:"Classic Rock", tempo:[95,145], swing:[50,54], groove:"rock", comp:"rockChugs",
    bass:"pickBass", keys:"piano", drums:"rock", kC:55,kF:30,bC:55,bF:25,dC:65,dF:40, halfOn:true, halfDen:[10,28], logic:"rockLogic" },
  rockAlt:{ name:"Alt / Indie Rock", tempo:[90,135], swing:[50,54], groove:"breaks", comp:"pushPull",
    bass:"round", keys:"guitarish", drums:"rock", kC:45,kF:25,bC:45,bF:20,dC:55,dF:35, halfOn:false, halfDen:[0,18], logic:"rockLogic" },

  bluesShuffle:{ name:"Blues Shuffle", tempo:[85,120], swing:[58,70], groove:"shuffle", comp:"fourComp",
    bass:"upright", keys:"ep", drums:"jazz", kC:55,kF:35,bC:60,bF:30,dC:65,dF:50, halfOn:true, halfDen:[10,28], logic:"bluesLogic" },
  bluesSlow:{ name:"Slow Blues", tempo:[60,85], swing:[55,65], groove:"shuffle", comp:"sustain",
    bass:"round", keys:"ep", drums:"brushes", kC:35,kF:18,bC:35,bF:15,dC:40,dF:25, halfOn:false, halfDen:[0,18], logic:"bluesLogic" },

  neoSoul:{ name:"Neo-Soul", tempo:[70,110], swing:[50,60], groove:"hiphop", comp:"neoSoulPush",
    bass:"sub", keys:"pad", drums:"lofi", kC:70,kF:55,bC:65,bF:50,dC:65,dF:55, halfOn:true, halfDen:[10,35], logic:"neoSoulLogic" },
  hiphop:{ name:"Hip-Hop", tempo:[70,100], swing:[50,58], groove:"hiphop", comp:"sparse",
    bass:"sub", keys:"pad", drums:"lofi", kC:35,kF:25,bC:45,bF:30,dC:45,dF:35, halfOn:false, halfDen:[0,18], logic:"edmLogic" },
  house:{ name:"House", tempo:[120,130], swing:[50,54], groove:"house", comp:"edmStab",
    bass:"squareBass", keys:"pad", drums:"house", kC:55,kF:35,bC:55,bF:25,dC:60,dF:35, halfOn:true, halfDen:[5,20], logic:"edmLogic" },
  techno:{ name:"Techno", tempo:[125,145], swing:[50,52], groove:"techno", comp:"edmStab",
    bass:"reese", keys:"fm", drums:"techno", kC:60,kF:45,bC:65,bF:35,dC:70,dF:50, halfOn:true, halfDen:[5,18], logic:"edmLogic" },
  dnb:{ name:"Drum & Bass", tempo:[165,190], swing:[50,52], groove:"dnb", comp:"arpeggio",
    bass:"reese", keys:"chip", drums:"dnb", kC:75,kF:55,bC:85,bF:45,dC:85,dF:55, halfOn:true, halfDen:[10,28], logic:"edmLogic" },
  breaks:{ name:"Breakbeat", tempo:[120,150], swing:[50,56], groove:"breaks", comp:"pushPull",
    bass:"round", keys:"fm", drums:"electro", kC:65,kF:45,bC:65,bF:35,dC:70,dF:50, halfOn:true, halfDen:[10,25], logic:"edmLogic" },
  ambient:{ name:"Ambient Minimal", tempo:[60,95], swing:[50,54], groove:"ambient", comp:"sustain",
    bass:"sub", keys:"noisePad", drums:"minimal", kC:25,kF:10,bC:25,bF:10,dC:20,dF:10, halfOn:false, halfDen:[0,12], logic:"jazzModal" },
  fusion:{ name:"Jazz-Rock Fusion", tempo:[110,170], swing:[50,58], groove:"funk", comp:"clav",
    bass:"fmBass", keys:"fm", drums:"tight", kC:80,kF:55,bC:80,bF:45,dC:80,dF:60, halfOn:true, halfDen:[18,40], logic:"fusionLogic" },
  free:{ name:"Free / Broken", tempo:[80,200], swing:[50,70], groove:"free", comp:"pushPull",
    bass:"wobble", keys:"glass", drums:"minimal", kC:90,kF:65,bC:90,bF:65,dC:90,dF:70, halfOn:true, halfDen:[25,70], logic:"none" },
};

/* ---------- Song shapes (50) - original templates (roman-ish) ---------- */
function makeSongLibrary(){
  // These are ‚Äústandard-like‚Äù FORM TEMPLATES: AABA, blues variants, rhythm-ish turns,
  // minor key turns, modal vamps, tritoney bridges, etc. They are NOT copied charts.
  // Each can reharmonize itself via your current limiter pool.
  const L = {};
  const add = (id,title,tempo,swing,chartText)=>{ L[id]={title,tempo,swing,chartText}; };

  add("none","None (use generator)",null,null,null);

  // AABA-ish (8-bar A, 8-bar B, 8-bar A) compressed to 16 for this UI.
  add("shape01","Shape 01 ‚Äî Bright AABA-ish (16)",170,62,`
| I, VI | ii, V | I | IV |
| iii | VI | ii | V |
| bIII | bVI | ii | V |
| I | VI | ii | V |
`.trim());

  add("shape02","Shape 02 ‚Äî Minor turnaround (16)",160,62,`
| i | iv | bVII | VI7 |
| ii√∏ | V7 | i | i |
| bIII | bVI | ii√∏ | V7 |
| i | V7 | i | i |
`.trim());

  add("shape03","Shape 03 ‚Äî Modal center + sidestep (12)",120,56,`
| i | i | bVII | bVII |
| IV | IV | i | i |
| bII | bII | i | i |
`.trim());

  add("shape04","Shape 04 ‚Äî ‚ÄúRhythm-ish‚Äù loop (16)",200,64,`
| I | VI | ii | V |
| I | VI | ii | V |
| IV | iv | I | VI |
| ii | V | I | V |
`.trim());

  add("shape05","Shape 05 ‚Äî Ballad cadences (8)",78,55,`
| I | iii | vi | ii |
| IV | V | I | I |
`.trim());

  add("shape06","Shape 06 ‚Äî Bluesy minor (12)",130,60,`
| i | i | iv | iv |
| i | bVI | V7 | V7 |
| iv | iv | i | V7 |
`.trim());

  add("shape07","Shape 07 ‚Äî ‚ÄúCycle‚Äù with surprises (16)",180,62,`
| I | VI | ii | V |
| iii | VI | ii | V |
| bVII | VI | ii | V |
| I | bII | I | V |
`.trim());

  add("shape08","Shape 08 ‚Äî Latin turnarounds (16)",160,52,`
| I | IV | iii | VI |
| ii | V | I | I |
| i | bVI | ii√∏ | V7 |
| I | V | I | I |
`.trim());

  add("shape09","Shape 09 ‚Äî Funk loop (8)",104,52,`
| i | bIII | IV | bVII |
| i | bIII | IV | V |
`.trim());

  add("shape10","Shape 10 ‚Äî Tritone bridge vibe (16)",170,60,`
| I | VI | ii | V |
| I | bII | I | V |
| bVI | bII | V | I |
| iii | VI | ii | V |
`.trim());

  // Generate a bunch more by variations (still original templates)
  const bases = [
    {name:"AABA-ish Alt", tempo:180, swing:62, txt:`
| I | VI | ii | V |
| I | IV | iii | VI |
| bIII | bVI | ii | V |
| I | V | I | I |
`.trim()},
    {name:"Minor AABA-ish", tempo:170, swing:62, txt:`
| i | VI7 | ii√∏ | V7 |
| i | iv | bVII | VI7 |
| bIII | bVI | ii√∏ | V7 |
| i | V7 | i | i |
`.trim()},
    {name:"Modal w/ cadence", tempo:130, swing:56, txt:`
| i | i | i | i |
| bVII | bVII | IV | IV |
| i | bII | i | V |
`.trim()},
    {name:"Bright Loop", tempo:124, swing:52, txt:`
| I | V | vi | IV |
| I | V | ii | V |
`.trim()},
    {name:"Planing / fusion", tempo:150, swing:54, txt:`
| I | bII | bIII | bII |
| I | bVI | V | I |
`.trim()},
    {name:"Shuffle bluesy", tempo:110, swing:66, txt:`
| I7 | IV7 | I7 | I7 |
| IV7 | IV7 | I7 | V7 |
| IV7 | I7 | V7 | I7 |
`.trim()},
  ];

  let idx = 11;
  for (let i=0;i<40;i++){
    const b = bases[i % bases.length];
    const id = `shape${String(idx).padStart(2,"0")}`;
    add(id, `Shape ${String(idx).padStart(2,"0")} ‚Äî ${b.name}`, b.tempo + (i%3===0? -10 : i%3===1? 0 : 10), b.swing, b.txt);
    idx++;
  }

  return L;
}
const SONG_LIBRARY = makeSongLibrary();

// --- Populate Song Shapes dropdown + hook change -> load ---
(function initSongShapesUI() {
  // build options
  els.songSelect.innerHTML = "";
  const ids = Object.keys(SONG_LIBRARY);
  
  // put "none" first, then the rest
  ids.sort((a, b) => {
    if (a === "none") return -1;
    if (b === "none") return 1;
    return a.localeCompare(b);
  });
  
  for (const id of ids) {
    const opt = document.createElement("option");
    opt.value = id;
    opt.textContent = SONG_LIBRARY[id].title || id;
    els.songSelect.appendChild(opt);
  }
  
  // default selection
  els.songSelect.value = "none";
  
  // change handler
  els.songSelect.addEventListener("change", () => {
    const id = els.songSelect.value;
    loadSongById(id);
  });
})();

/* ---------- Roman chart parsing to ‚Äúreal‚Äù chords in current key ---------- */
function parseRomanChartToBars(text, keyRootPc){
  const DEGREE = { "I":0,"ii":2,"iii":4,"IV":5,"V":7,"VI":9,"vii":11, "bVII":10,"bVI":8,"bIII":3,"bII":1, "i":0 };
  const rawBars = text.replace(/\r/g,"").split("|").map(s=>s.trim()).filter(Boolean);

  const limiter = getChordLimiterState();
  const qPool = buildQualityOptions(limiter);

  function chooseQualityForRoman(roman){
    const core = roman.replace(/\s+/g,"");
    const isLower = /^[a-z]/.test(core.replace(/^b/,""));
    const isDom = /V/.test(core.replace(/^b/,"")) && !isLower;
    let wantFamily = "maj";
    if (isLower) wantFamily = "min";
    if (isDom) wantFamily = "dom";
    const candidates = qPool.filter(o=>o.v.family===wantFamily);
    return candidates.length ? weightedPick(candidates) : weightedPick(qPool);
  }

  function romanToRoot(roman){
    const core = roman.replace(/\s+/g,"");
    const flat = core.startsWith("b");
    const base = core.replace(/^b/,"").replace(/[^IViv]+/g,"");
    const deg = DEGREE[flat ? ("b"+base) : base];
    if (deg==null) return null;
    return pc(keyRootPc + deg);
  }

  const barsOut = [];
  for (const cell of rawBars){
    const halves = cell.split(",").map(s=>s.trim()).filter(Boolean);
    if (halves.length<=1){
      const roman = halves[0] || "I";
      const root = romanToRoot(roman) ?? keyRootPc;
      const q = chooseQualityForRoman(roman).v;
      barsOut.push({ split:false, chords:[{ root, family:q.family, symbol:q.display, intervals:(CHORDS[q.symbol]||CHORDS.dom7).slice(), slash:null }] });
    } else {
      const a = halves[0], b = halves[1];
      const rootA = romanToRoot(a) ?? keyRootPc;
      const rootB = romanToRoot(b) ?? keyRootPc;
      const qa = chooseQualityForRoman(a).v;
      const qb = chooseQualityForRoman(b).v;
      barsOut.push({
        split:true,
        chords:[
          { root:rootA, family:qa.family, symbol:qa.display, intervals:(CHORDS[qa.symbol]||CHORDS.dom7).slice(), slash:null },
          { root:rootB, family:qb.family, symbol:qb.display, intervals:(CHORDS[qb.symbol]||CHORDS.dom7).slice(), slash:null },
        ]
      });
    }
  }
  return barsOut;
}
function loadSongById(songId){
  const s = SONG_LIBRARY[songId] || SONG_LIBRARY.none;
  if (!s || !s.chartText){
    els.msg.textContent = "Song shapes: none (generator mode).";
    return;
  }
  // pick a key center if none exists yet
  if (state.keyRoot == null) state.keyRoot = rint(0, 11);
  const keyRootPc = state.keyRoot;

  if (s.tempo){
    state.tempo = s.tempo|0;
    els.tempo.value = state.tempo; els.tempoNum.value = state.tempo;
  }
  if (s.swing!=null){
    state.swing = s.swing|0;
    els.swing.value = state.swing; els.swingNum.value = state.swing;
  }
  player.setTempo(state.tempo, state.swing);

  const bars = parseRomanChartToBars(s.chartText, keyRootPc);

  state.chartBars = bars;
  state.bars = bars.length;
  els.bars.value = state.bars; els.barsNum.value = state.bars;

  state.activeBar = 0; state.activeHalf = 0;
  renderAll();

    // Always update player chart, even if not currently playing
  player.setChart(state.chartBars);
  player.jumpTo(0, 0);
  
  // If already playing, keep it rolling from the start of the loaded form
  if (player.isPlaying) {
    // no extra needed; jumpTo above already moved it
  }
  els.msg.textContent = `Loaded: ${s.title}`;
}

/* ---------- Fill shapes (random ‚Äútypes of fills‚Äù so it doesn‚Äôt repeat) ---------- */
  const FILL_SHAPES = {
    none:(t)=>0,
    rampUp:(t)=>t,
    rampDown:(t)=>1-t,
    pyramid:(t)=>(t<0.5 ? (t*2) : (2*(1-t))),
    pulse2:(t)=>(Math.sin(t*Math.PI*2)*0.5+0.5),
    pulse3:(t)=>(Math.sin(t*Math.PI*3)*0.5+0.5),
    stutter:(t)=>(t<0.2?1: t<0.4?0: t<0.6?1: t<0.8?0:1),
    randomWalk:(()=>{
      let v=Math.random();
      return ()=>{ v=clamp(v + (Math.random()-.5)*0.35,0,1); return v; };
    })(),
  };

  function pickFillShapeId(){
    const ids = ["pyramid","pulse2","pulse3","rampUp","rampDown","stutter","none"];
    return pick(ids);
  }

  /* ---------- WebAudio: shared engine (tap audition always works) ---------- */
  const audio = (() => {
    const AC = window.AudioContext || window.webkitAudioContext;
    const ctx = new AC();
    const master = ctx.createGain();
    master.gain.value = 0.9;
    master.connect(ctx.destination);

    // simple safety limiter-ish
    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -18;
    comp.knee.value = 18;
    comp.ratio.value = 4;
    comp.attack.value = 0.005;
    comp.release.value = 0.12;
    master.disconnect();
    master.connect(comp);
    comp.connect(ctx.destination);

    function now(){ return ctx.currentTime; }
    async function ensure(){ if (ctx.state !== "running") await ctx.resume(); }

    function envGain(g, t0, a=0.006, d=0.14, s=0.0, r=0.12, peak=1.0){
      g.gain.cancelScheduledValues(t0);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.linearRampToValueAtTime(peak, t0 + a);
      g.gain.linearRampToValueAtTime(Math.max(0.0001, peak*s), t0 + a + d);
      g.gain.linearRampToValueAtTime(0.0001, t0 + a + d + r);
    }

    function biquad(type, freq, Q=0.7){
      const f = ctx.createBiquadFilter();
      f.type = type;
      f.frequency.value = freq;
      f.Q.value = Q;
      return f;
    }

    function hzFromMidi(m){ return 440 * Math.pow(2, (m-69)/12); }

    // Minimal-ish synth voices (keys/bass)
    function makeVoice(preset){
      const g = ctx.createGain();
      g.gain.value = 0;
      g.connect(master);

      const chain = [];
      function connectChain(src){
        let cur = src;
        for (const n of chain){ cur.connect(n); cur = n; }
        cur.connect(g);
      }

      // default filter
      const lp = biquad("lowpass", 6000, 0.7);
      const hp = biquad("highpass", 40, 0.7);

      // subtle chorus-ish via detune on multiple oscs (cheap)
      function osc(type, det=0){
        const o = ctx.createOscillator();
        o.type = type;
        o.detune.value = det;
        return o;
      }

      function addNoise(){
        const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.15, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * Math.exp(-i/(data.length*0.25));
        const src = ctx.createBufferSource();
        src.buffer = buffer;
        return src;
      }

      function playNote(midi, t, dur, vel=0.8){
        const f = hzFromMidi(midi);

        // basic per-preset mapping
        let types = ["sine"];
        let dets = [0];
        let cut = 6000;
        let atk = 0.006, dec=0.14, rel=0.12;
        let peak = 0.34 * vel;

        if (preset==="piano"){ types=["triangle","sine"]; dets=[0, -3]; cut=4200; peak=0.38*vel; dec=0.18; rel=0.10; }
        if (preset==="ep"){ types=["sine","triangle"]; dets=[0, +4]; cut=5000; peak=0.36*vel; dec=0.20; rel=0.12; }
        if (preset==="organ"){ types=["sine","sine","sine"]; dets=[0,+2,-2]; cut=9000; peak=0.26*vel; atk=0.004; dec=0.04; rel=0.08; }
        if (preset==="pad"){ types=["sine","triangle"]; dets=[0,+6]; cut=2500; peak=0.22*vel; atk=0.03; dec=0.10; rel=0.22; }
        if (preset==="fm"){ types=["sine","sine"]; dets=[0,+7]; cut=5200; peak=0.28*vel; dec=0.12; rel=0.10; }
        if (preset==="chip"){ types=["square","square"]; dets=[0,+10]; cut=6500; peak=0.16*vel; dec=0.09; rel=0.07; }
        if (preset==="bell"){ types=["sine","sine"]; dets=[0,+19]; cut=7200; peak=0.22*vel; dec=0.16; rel=0.18; }
        if (preset==="glass"){ types=["triangle","sine"]; dets=[0,+14]; cut=6800; peak=0.22*vel; dec=0.12; rel=0.16; }
        if (preset==="pluck2"){ types=["triangle","triangle"]; dets=[0,+9]; cut=5600; peak=0.24*vel; dec=0.10; rel=0.10; }
        if (preset==="vibes"){ types=["sine","triangle"]; dets=[0,+12]; cut=7000; peak=0.24*vel; dec=0.14; rel=0.18; }
        if (preset==="choirPad"){ types=["sine","triangle"]; dets=[0,+5]; cut=2200; peak=0.20*vel; atk=0.04; dec=0.12; rel=0.24; }
        if (preset==="noisePad"){ types=["sine"]; dets=[0]; cut=1800; peak=0.18*vel; atk=0.05; dec=0.10; rel=0.28; }
        if (preset==="guitarish"){ types=["triangle","triangle"]; dets=[0,+3]; cut=4800; peak=0.20*vel; dec=0.08; rel=0.10; }
        if (preset==="clavBright"){ types=["square","triangle"]; dets=[0,+5]; cut=8000; peak=0.18*vel; dec=0.07; rel=0.06; }

        // bass presets
        if (preset==="upright"){ types=["sine","triangle"]; dets=[0,+2]; cut=900; peak=0.42*vel; dec=0.12; rel=0.10; }
        if (preset==="round"){ types=["sine","triangle"]; dets=[0,+1]; cut=1200; peak=0.44*vel; dec=0.12; rel=0.10; }
        if (preset==="sub"){ types=["sine"]; dets=[0]; cut=700; peak=0.55*vel; dec=0.10; rel=0.10; }
        if (preset==="pluck"){ types=["triangle"]; dets=[0]; cut=1400; peak=0.42*vel; dec=0.06; rel=0.08; }
        if (preset==="fmBass"){ types=["sine","sine"]; dets=[0,+7]; cut=1400; peak=0.50*vel; dec=0.08; rel=0.10; }
        if (preset==="rubber"){ types=["triangle","sine"]; dets=[0,+9]; cut=1000; peak=0.45*vel; dec=0.09; rel=0.10; }
        if (preset==="acid"){ types=["sawtooth","square"]; dets=[0,+2]; cut=900; peak=0.40*vel; dec=0.08; rel=0.09; }
        if (preset==="reese"){ types=["sawtooth","sawtooth"]; dets=[-10,+10]; cut=1000; peak=0.34*vel; dec=0.10; rel=0.12; }
        if (preset==="squareBass"){ types=["square"]; dets=[0]; cut=900; peak=0.40*vel; dec=0.08; rel=0.10; }
        if (preset==="wobble"){ types=["sawtooth"]; dets=[0]; cut=900; peak=0.35*vel; dec=0.10; rel=0.12; }
        if (preset==="pickBass"){ types=["square","triangle"]; dets=[0,+3]; cut=1300; peak=0.36*vel; dec=0.07; rel=0.08; }
        if (preset==="muted"){ types=["triangle"]; dets=[0]; cut=900; peak=0.38*vel; dec=0.05; rel=0.07; }

        lp.frequency.setValueAtTime(cut, t);
        hp.frequency.setValueAtTime(40, t);

        // build chain
        chain.length = 0;
        chain.push(hp, lp);

        // voice
        const sum = ctx.createGain();
        sum.gain.value = 1;
        connectChain(sum);

        const oscs = [];
        for (let i=0;i<types.length;i++){
          const o = osc(types[i], dets[i]||0);
          o.frequency.setValueAtTime(f, t);
          o.start(t);
          o.stop(t + Math.max(0.05, dur + 0.25));
          o.connect(sum);
          oscs.push(o);
        }

        // tiny transient for some presets
        if (preset==="piano" || preset==="ep" || preset==="clavBright" || preset==="pluck" || preset==="pluck2" || preset==="guitarish"){
          const n = addNoise();
          const ng = ctx.createGain();
          ng.gain.value = 0.12 * vel;
          const nlp = biquad("lowpass", preset==="clavBright" ? 6000 : 3500, 0.7);
          n.connect(nlp); nlp.connect(ng); ng.connect(sum);
          n.start(t); n.stop(t + 0.07);
        }

        envGain(g, t, atk, dec, 0.0, rel, peak);
      }

      return { playNote };
    }

    // drums (very lightweight synthesis)
    function makeDrums(preset){
      function noiseBuf(len){
        const buffer = ctx.createBuffer(1, ctx.sampleRate * len, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1);
        return buffer;
      }
      const noise = noiseBuf(0.25);
      const noise2 = noiseBuf(0.08);

      function hitNoise(t, len, amp, hpFreq, lpFreq){
        const src = ctx.createBufferSource();
        src.buffer = (len<0.12)?noise2:noise;
        const g = ctx.createGain();
        const hp = biquad("highpass", hpFreq, 0.7);
        const lp = biquad("lowpass", lpFreq, 0.7);
        g.gain.value = 0.0001;
        src.connect(hp); hp.connect(lp); lp.connect(g); g.connect(master);

        g.gain.setValueAtTime(0.0001, t);
        g.gain.linearRampToValueAtTime(amp, t+0.002);
        g.gain.exponentialRampToValueAtTime(0.0001, t+len);

        src.start(t);
        src.stop(t+len+0.02);
      }

      function kick(t, vel){
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = "sine";
        o.frequency.setValueAtTime(120, t);
        o.frequency.exponentialRampToValueAtTime(45, t+0.09);
        g.gain.setValueAtTime(0.0001, t);
        g.gain.linearRampToValueAtTime((preset==="techno"?0.95:0.75)*vel, t+0.003);
        g.gain.exponentialRampToValueAtTime(0.0001, t+0.15);
        o.connect(g); g.connect(master);
        o.start(t); o.stop(t+0.18);
      }

      function snare(t, vel){
        hitNoise(t, preset==="brushes"?0.12:0.09, (preset==="jazz"?0.20:0.28)*vel, preset==="brushes"?200:700, 7000);
        // body tone
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = "triangle";
        o.frequency.setValueAtTime(190, t);
        g.gain.setValueAtTime(0.0001, t);
        g.gain.linearRampToValueAtTime((preset==="jazz"?0.12:0.16)*vel, t+0.003);
        g.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
        o.connect(g); g.connect(master);
        o.start(t); o.stop(t+0.14);
      }

      function hat(t, vel, open=false){
        const len = open ? 0.12 : 0.045;
        const ampBase =
          preset==="trap" ? 0.22 :
          preset==="lofi" ? 0.14 :
          preset==="minimal" ? 0.10 :
          preset==="house" ? 0.18 :
          preset==="dnb" ? 0.20 :
          preset==="techno" ? 0.18 :
          0.16;
        hitNoise(t, len, ampBase*vel, 4500, 12000);
      }

      function ride(t, vel){
        const amp = preset==="jazz" ? 0.14 : 0.10;
        hitNoise(t, 0.08, amp*vel, 2500, 10500);
      }

      function brush(t, vel){
        // swish
        hitNoise(t, 0.16, 0.11*vel, 1800, 8000);
      }

      function tom(t, vel){
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = "sine";
        o.frequency.setValueAtTime(160, t);
        o.frequency.exponentialRampToValueAtTime(90, t+0.12);
        g.gain.setValueAtTime(0.0001, t);
        g.gain.linearRampToValueAtTime(0.28*vel, t+0.003);
        g.gain.exponentialRampToValueAtTime(0.0001, t+0.20);
        o.connect(g); g.connect(master);
        o.start(t); o.stop(t+0.22);
      }

      return { kick, snare, hat, ride, brush, tom };
    }

    return { ctx, ensure, now, makeVoice, makeDrums };
  })();

  /* ---------- Player / Transport (UI synced) ---------- */
  const player = (() => {
    let keysVoice = audio.makeVoice(state.keysPreset);
    let bassVoice = audio.makeVoice(state.bassPreset);
    let drums = audio.makeDrums(state.drumsPreset);

    let tempo = DEFAULTS.tempo;
    let swing = DEFAULTS.swing; // 50..75
    let isPlaying = false;

    // scheduling
    const lookahead = 0.12;
    const intervalMs = 25;
    let timer = null;

    // chart + position
    let chart = [];
    let barIndex = 0;
    let halfIndex = 0;
    let stepInHalf = 0;     // 0..(subdiv-1)
    let nextNoteTime = 0;

    function setTempo(t, sw){
      tempo = clamp(t, 30, 320);
      swing = clamp(sw, 50, 80);
    }
    function beatDur(){ return 60 / tempo; }
    function swingFactor(){ return (swing - 50) / 25; } // 0..1
    function swungStepTime(step, stepsPerBeat){
      // apply swing to 8th-note grid (stepsPerBeat=2)
      // for higher grids, only swing the 2nd 8th within each beat.
      const b = beatDur();
      const base = b / stepsPerBeat;
      if (stepsPerBeat < 2) return base;
      const posInBeat = step % stepsPerBeat;
      if (stepsPerBeat === 2){
        // push the "and" later by up to ~18%
        return posInBeat === 1 ? base * (1.0 + 0.35*swingFactor()) : base * (1.0 - 0.35*swingFactor());
      } else {
        // subtle: only bias the midpoint
        if (posInBeat === Math.floor(stepsPerBeat/2)) return base * (1.0 + 0.20*swingFactor());
        return base;
      }
    }

    function setChart(bars){
      chart = bars || [];
    }
    function jumpTo(b, h){
      barIndex = clamp(b|0, 0, Math.max(0, chart.length-1));
      halfIndex = clamp(h|0, 0, 1);
      stepInHalf = 0;
      nextNoteTime = audio.now() + 0.03;
    }

    function refreshVoices(){
      keysVoice = audio.makeVoice(state.keysPreset);
      bassVoice = audio.makeVoice(state.bassPreset);
      drums = audio.makeDrums(state.drumsPreset);
    }

    function currentChord(){
      if (!chart.length) return null;
      const bar = chart[barIndex];
      if (!bar) return null;
      if (!bar.split) return bar.chords[0];
      return bar.chords[halfIndex] || bar.chords[0];
    }

    // comp patterns (keys)
    function compPattern(style, beatsInHalf){
      // returns hit times within the half in beats (0..beatsInHalf)
      const b = beatsInHalf;
      if (style==="twoStabs") return [0, b/2];
      if (style==="fourComp") return (b===2)?[0,1]:[0,1,2,3];
      if (style==="charleston") return (b===2)?[0,1.5]:[0,1.5,2,3.5];
      if (style==="anticipations") return (b===2)?[0.75,1.75]:[0.75,1.75,2.75,3.75];
      if (style==="pushPull") return (b===2)?[0,1.25,1.75]:[0,1.25,1.75,2.75,3.25];
      if (style==="sparse") return (b===2)?[0.0]:[0,2.5];
      if (style==="arpeggio") return (b===2)?[0,0.5,1,1.5]:[0,0.5,1,1.5,2,2.5,3,3.5];
      if (style==="sustain") return [0];
      if (style==="montuno") return (b===2)?[0,0.75,1.25,1.75]:[0,0.75,1.25,2,2.75,3.25];
      if (style==="clav") return (b===2)?[0,0.5,1.25,1.5]:[0,0.5,1.25,1.5,2.25,2.5,3.25,3.5];
      if (style==="rockChugs") return (b===2)?[0,0.5,1,1.5]:[0,0.5,1,1.5,2,2.5,3,3.5];
      if (style==="discoChop") return (b===2)?[0.5,1.5]:[0.5,1.5,2.5,3.5];
      if (style==="neoSoulPush") return (b===2)?[0.25,0.75,1.5]:[0.25,0.75,1.5,2.25,2.75,3.5];
      if (style==="edmStab") return (b===2)?[0,1]:[0,1,2,3];
      return [0, b/2];
    }

    // bass patterns
    function bassPattern(groove, beatsInHalf){
      const b=beatsInHalf;
      if (groove==="house"||groove==="techno") return (b===2)?[0,1]:[0,1,2,3];
      if (groove==="dnb"||groove==="breaks") return (b===2)?[0,1.5]:[0,1.5,2.5,3.5];
      if (groove==="hiphop"||groove==="ambient") return (b===2)?[0]:[0,2];
      if (groove==="bossa"||groove==="samba"||groove==="afroCuban") return (b===2)?[0,1.5]:[0,1.5,2,3.5];
      if (groove==="funk"||groove==="disco") return (b===2)?[0,0.75,1.5]:[0,0.75,1.5,2.25,3.0];
      // jazz-ish
      return (b===2)?[0,1]:[0,1,2,3];
    }

    // drum patterns: step grid in 8ths (2 per beat)
    function drumGrid(groove){
      // returns per-half arrays of events: {step, kind, vel}
      // step is in 8ths within the half (beatsInHalf * 2).
      return groove;
    }

    function scheduleNote(t){
      if (!chart.length) return;

      const bar = chart[barIndex];
      const beatsInBar = 4;
      const beatsInHalf = bar && bar.split ? 2 : 4;

      // 8ths grid
      const stepsPerBeat = 2;
      const stepsInHalf = beatsInHalf * stepsPerBeat;

      const chord = currentChord();
      if (!chord) return;

      // UI sync: update active chord at the start of each half
      if (stepInHalf === 0){
        state.activeBar = barIndex;
        state.activeHalf = halfIndex;
        renderLeadActive();
        renderPianoForActive();
      }

      // compute "beat within half" for this step
      const beatWithinHalf = stepInHalf / stepsPerBeat;

      // Fills / complexity (0..100)
      const kC = clamp(state.keysComplex,0,100)/100;
      const kF = clamp(state.keysFill,0,100)/100;
      const bC = clamp(state.bassComplex,0,100)/100;
      const bF = clamp(state.bassFill,0,100)/100;
      const dC = clamp(state.drumsComplex,0,100)/100;
      const dF = clamp(state.drumsFill,0,100)/100;

      // end-of-half fill likelihood (shape)
      const tNorm = stepsInHalf<=1 ? 0 : (stepInHalf/(stepsInHalf-1));
      const kShape = (FILL_SHAPES[state.fillShapeKeys] || FILL_SHAPES.pyramid);
      const bShape = (FILL_SHAPES[state.fillShapeBass] || FILL_SHAPES.pulse2);
      const dShape = (FILL_SHAPES[state.fillShapeDrums] || FILL_SHAPES.stutter);

      const kFillNow = kF * (0.25 + 0.75*kShape(tNorm));
      const bFillNow = bF * (0.25 + 0.75*bShape(tNorm));
      const dFillNow = dF * (0.25 + 0.75*dShape(tNorm));

      // KEYS: comp hits (on beat positions; add extra if complexity/fills)
      const hits = compPattern(state.compStyle, beatsInHalf);
      const isHit = hits.some(h => Math.abs(h - beatWithinHalf) < 0.001);
      const extraHit = (!isHit && chance((kC*0.10 + kFillNow*0.18) / stepsPerBeat));

      if (isHit || extraHit){
        // voice chord (simple voicing)
        const tones = chordTonesPCs(chord);
        const root = chord.root;

        // spread voicing around middle
        const baseMidi = 60; // C4
        const rootMidi = baseMidi + (pc(root) - 0);
        const sorted = tones.slice().sort((a,b)=>a-b);

        // build 4-5 note voicing
        const voicing = [];
        const addTone = (p, oct)=> voicing.push((baseMidi-12) + p + 12*oct);

        // choose octave placement that keeps in range
        addTone(pc(root), 0);
        for (let i=1;i<Math.min(sorted.length,4);i++){
          addTone(sorted[i], i%2===0 ? 0 : 1);
        }
        if (chance(kC*0.25)) addTone(sorted[sorted.length-1], 1);

        // velocity based on style
        let vel = 0.75;
        if (state.compStyle==="sustain") vel = 0.55;
        if (state.compStyle==="discoChop" || state.compStyle==="clav") vel = 0.65;
        vel *= (0.6 + 0.4*kC);

        const durBeats = state.compStyle==="sustain" ? beatsInHalf : (extraHit ? 0.5 : 0.8);
        const dur = durBeats * beatDur();

        for (const m of voicing){
          keysVoice.playNote(m, t, dur, vel);
        }
      }

      // BASS: walk/ostinato-ish
      const bassHits = bassPattern(state.grooveStyle, beatsInHalf);
      const isBass = bassHits.some(h => Math.abs(h - beatWithinHalf) < 0.001);
      const bassExtra = (!isBass && chance(bC*0.07 + bFillNow*0.12));

      if (isBass || bassExtra){
        const rootPc = chord.root;
        const chordPCs = chordTonesPCs(chord);

        // choose bass tone: root most of time, then 5th/3rd with complexity
        const options = [
          {v: rootPc, w: 1.4},
          {v: pc(rootPc+7), w: 0.6 + bC*0.6},
          {v: chordPCs.includes(pc(rootPc+3)) ? pc(rootPc+3) : pc(rootPc+4), w: 0.5 + bC*0.6},
          {v: pc(rootPc+10), w: 0.2 + bFillNow*0.6},
          {v: pc(rootPc+2), w: 0.2 + bFillNow*0.5},
        ];
        const tonePc = weightedPick(options);
        const midi = 36 + tonePc; // C2 area
        const dur = beatDur() * (isBass ? 0.92 : 0.55);
        const vel = (0.65 + 0.35*bC) * (isBass ? 0.85 : 0.65);
        bassVoice.playNote(midi, t, dur, vel);
      }

      // DRUMS: based on groove (8ths grid)
      const step = stepInHalf; // 8ths within half
      const downbeat = (step % (2*2) === 0); // every 2 beats (in 8ths)
      const onBeat = (step % 2 === 0);
      const off = !onBeat;

      const drumsLvl = clamp(state.drumsLevel,0,100)/100;

      function doKick(v){ drums.kick(t, v*drumsLvl); }
      function doSnare(v){ drums.snare(t, v*drumsLvl); }
      function doHat(v, open=false){ drums.hat(t, v*drumsLvl, open); }
      function doRide(v){ drums.ride(t, v*drumsLvl); }
      function doBrush(v){ drums.brush(t, v*drumsLvl); }
      function doTom(v){ drums.tom(t, v*drumsLvl); }

      // fills (end of half)
      const fillBoost = dFillNow;

      const g = state.grooveStyle;

      if (g==="swing"){
        // ride pattern: ding-ding-da-ding
        if (onBeat) doRide(0.8 + 0.3*dC);
        if (off && chance(0.55 + dC*0.25)) doRide(0.45 + 0.25*dC);
        // hats on 2&4 (in 8ths of half: beats 1 and 3 for full bar; adapt)
        const beat = step/2;
        if (Math.abs(beat - 1) < 0.001 || Math.abs(beat - 3) < 0.001) doHat(0.35 + 0.25*dC, false);
        if (chance(0.05 + dC*0.12)) doSnare(0.18 + 0.15*dC);
        if (chance(0.03 + fillBoost*0.16) && step >= stepsInHalf-2) doTom(0.35 + 0.30*dC);
      } else if (g==="brushBallad"){
        if (onBeat) doBrush(0.55 + 0.20*dC);
        if (chance(0.06 + dC*0.10)) doSnare(0.15 + 0.10*dC);
        if (chance(0.05 + fillBoost*0.20) && step >= stepsInHalf-2) doBrush(0.65);
      } else if (g==="bossa"){
        // clave-ish hats + light snare
        if (onBeat) doHat(0.35 + 0.25*dC, false);
        if (step===0 || step===3 || step===5 || step===7) doHat(0.30, false);
        if (step===2 || step===6) doSnare(0.18 + 0.12*dC);
        if (chance(0.04 + fillBoost*0.15) && step >= stepsInHalf-2) doTom(0.30);
      } else if (g==="samba"){
        if (onBeat) doHat(0.40 + 0.25*dC, chance(0.08 + dC*0.10));
        if (step===0 || step===4) doKick(0.55 + 0.25*dC);
        if (step===2 || step===6) doSnare(0.22 + 0.14*dC);
      } else if (g==="afroCuban"){
        if (onBeat) doHat(0.35 + 0.25*dC, false);
        if (step===0 || step===3 || step===5) doSnare(0.20 + 0.15*dC);
        if (step===0 || step===4) doKick(0.55 + 0.25*dC);
      } else if (g==="funk"){
        if (onBeat) doHat(0.32 + 0.35*dC, chance(0.10 + dC*0.15));
        if (step===0 || step===4) doKick(0.60 + 0.30*dC);
        if (step===2 || step===6) doSnare(0.35 + 0.25*dC);
        if (chance(0.05 + fillBoost*0.20) && step >= stepsInHalf-3) doSnare(0.25);
      } else if (g==="disco"){
        if (onBeat) doHat(0.40 + 0.25*dC, false);
        if (step%2===0) doKick(0.65 + 0.20*dC);
        if (step===2 || step===6) doSnare(0.28 + 0.18*dC);
      } else if (g==="rock"){
        if (onBeat) doHat(0.28 + 0.28*dC, false);
        if (step===0 || step===4) doKick(0.65 + 0.25*dC);
        if (step===2 || step===6) doSnare(0.40 + 0.20*dC);
      } else if (g==="shuffle"){
        // swing hats, shuffle snare
        if (onBeat) doHat(0.30 + 0.30*dC, false);
        if (off && chance(0.45 + 0.25*dC)) doHat(0.22, false);
        if (step===0 || step===4) doKick(0.62 + 0.20*dC);
        if (step===2 || step===6) doSnare(0.38 + 0.18*dC);
      } else if (g==="hiphop"){
        if (onBeat && chance(0.65)) doHat(0.22 + 0.22*dC, false);
        if (chance(0.22 + 0.25*dC)) doHat(0.18, false);
        if (step===0 || (chance(0.18 + 0.20*dC) && step===3)) doKick(0.70 + 0.20*dC);
        if (step===4 || (chance(0.12 + 0.20*dC) && step===6)) doSnare(0.45 + 0.20*dC);
      } else if (g==="house" || g==="techno"){
        if (onBeat) doHat(0.25 + 0.20*dC, false);
        if (step%2===0) doKick(0.80 + 0.15*dC);
        if (step===2 || step===6) doHat(0.22, true);
      } else if (g==="dnb"){
        if (chance(0.65 + 0.25*dC)) doHat(0.22 + 0.20*dC, false);
        if (step===0 || step===3 || step===4 || step===7) doKick(0.70 + 0.20*dC);
        if (step===2 || step===6) doSnare(0.55 + 0.20*dC);
      } else if (g==="breaks"){
        if (chance(0.55 + 0.25*dC)) doHat(0.22 + 0.22*dC, false);
        if (step===0 || step===4) doKick(0.70 + 0.20*dC);
        if (step===2 || step===6) doSnare(0.50 + 0.20*dC);
        if (chance(0.05 + fillBoost*0.25) && step>=stepsInHalf-3) doSnare(0.30);
      } else if (g==="ambient"){
        if (chance(0.12 + 0.25*dC)) doHat(0.10 + 0.10*dC, false);
        if (chance(0.02 + fillBoost*0.08) && step>=stepsInHalf-2) doHat(0.14, true);
      } else if (g==="free"){
        if (chance(0.30 + 0.45*dC)) doRide(0.55);
        if (chance(0.10 + 0.25*dC)) doSnare(0.25);
        if (chance(0.10 + 0.20*dC)) doHat(0.22, chance(0.35));
        if (chance(0.06 + fillBoost*0.22) && step>=stepsInHalf-3) doTom(0.45);
      }

      // advance step/time
      const stepDur = swungStepTime(stepInHalf, stepsPerBeat);
      nextNoteTime += stepDur;

      stepInHalf++;
      if (stepInHalf >= stepsInHalf){
        stepInHalf = 0;

        // next half or bar
        if (bar && bar.split){
          halfIndex = (halfIndex===0) ? 1 : 0;
          if (halfIndex===0) barIndex++;
        } else {
          barIndex++;
          halfIndex = 0;
        }

        if (barIndex >= chart.length){
          barIndex = 0; halfIndex = 0;
          // new random fill shapes each loop (reduces repeats)
          state.fillShapeKeys = pickFillShapeId();
          state.fillShapeBass = pickFillShapeId();
          state.fillShapeDrums = pickFillShapeId();
        }
      }
    }

    function scheduler(){
      const cur = audio.now();
      while (nextNoteTime < cur + lookahead){
        scheduleNote(nextNoteTime);
      }
    }

    async function start(){
      await audio.ensure();
      if (!chart.length) return;
      if (isPlaying) return;

      refreshVoices();
      isPlaying = true;
      nextNoteTime = audio.now() + 0.04;

      timer = setInterval(scheduler, intervalMs);
    }
    function stop(){
      isPlaying = false;
      if (timer){ clearInterval(timer); timer = null; }
    }

    return {
      get isPlaying(){ return isPlaying; },
      setTempo, setChart, jumpTo, start, stop, refreshVoices,
      getPosition: ()=>({barIndex, halfIndex}),
    };
  })();

  /* ---------- Lead sheet rendering + click audition ---------- */
  function getChordAt(barIdx, halfIdx){
    const bar = state.chartBars[barIdx];
    if (!bar) return null;
    if (!bar.split) return { chord:bar.chords[0], half:0 };
    return { chord: bar.chords[halfIdx||0] || bar.chords[0], half: halfIdx||0 };
  }

  function previewChord(ch){
    if (!ch) return;
    audio.ensure(); // no await; user gesture will have resumed if needed
    // short arpeggiated preview
    const t0 = audio.now() + 0.01;
    const pcs = chordTonesPCs(ch);
    const root = ch.root;

    const base = 60; // C4
    const midiRoot = base + pc(root);
    const tones = [];
    // include root then other chord tones in ascending order
    tones.push(midiRoot);
    pcs.slice().sort((a,b)=>a-b).forEach(p=>{
      if (p!==pc(root)) tones.push(base + p);
    });

    const dur = 0.22;
    let t = t0;
    for (let i=0;i<tones.length;i++){
      player.refreshVoices(); // ensures preset changes reflect quickly
      const kv = audio.makeVoice(state.keysPreset);
      kv.playNote(tones[i], t, dur, 0.75);
      t += 0.06;
    }
  }

  function renderLead(){
    els.sheet.innerHTML = "";
    const bars = state.chartBars || [];
    for (let i=0;i<bars.length;i++){
      const bar = bars[i];
      const d = document.createElement("div");
      d.className = "bar";
      d.dataset.i = String(i);

      const num = document.createElement("div");
      num.className = "num";
      num.textContent = String(i+1);
      d.appendChild(num);

      const sym = document.createElement("div");
      sym.className = "sym";
      const mainChord = bar.chords[0];
      sym.textContent = chordName(mainChord);
      d.appendChild(sym);

      if (bar.split){
        const sym2 = document.createElement("div");
        sym2.className = "sym sym2";
        sym2.textContent = chordName(bar.chords[1]);
        d.appendChild(sym2);

        const halfHit = document.createElement("div");
        halfHit.className = "halfHit";

        const topBtn = document.createElement("button");
        topBtn.type="button";
        topBtn.addEventListener("click",(e)=>{
          e.stopPropagation();
          setActive(i,0,true);
        });

        const botBtn = document.createElement("button");
        botBtn.type="button";
        botBtn.addEventListener("click",(e)=>{
          e.stopPropagation();
          setActive(i,1,true);
        });

        halfHit.appendChild(topBtn);
        halfHit.appendChild(botBtn);
        d.appendChild(halfHit);
      } else {
        d.addEventListener("click", ()=> setActive(i,0,true));
      }

      els.sheet.appendChild(d);
    }
    renderLeadActive();
  }

  function renderLeadActive(){
    const nodes = els.sheet.querySelectorAll(".bar");
    nodes.forEach(n=>{
      const i = Number(n.dataset.i);
      const active = i===state.activeBar;
      n.classList.toggle("active", active);
    });
  }

  function setActive(barIdx, halfIdx, audition){
    state.activeBar = clamp(barIdx, 0, Math.max(0,state.chartBars.length-1));
    state.activeHalf = clamp(halfIdx|0, 0, 1);

    renderLeadActive();
    renderPianoForActive();

    if (audition){
      const got = getChordAt(state.activeBar, state.activeHalf);
      if (got && got.chord) previewChord(got.chord);
    }

    // If playing, jump transport so audio/UI stays in lockstep.
    if (player.isPlaying){
      player.jumpTo(state.activeBar, state.activeHalf);
    }
  }

  /* ---------- Piano rendering ---------- */
  function renderPianoForActive(){
    const got = getChordAt(state.activeBar, state.activeHalf);
    const ch = got ? got.chord : null;
    if (!ch){
      els.pianoTop.textContent = "‚Äî";
      els.pianoHint.textContent = "‚Äî";
      drawPiano([], [], null, "mixo");
      return;
    }

    const prev = (state.activeBar>0) ? getChordAt(state.activeBar-1, 1)?.chord || getChordAt(state.activeBar-1, 0)?.chord : null;
    const next = (state.activeBar < state.chartBars.length-1) ? getChordAt(state.activeBar+1, 0)?.chord : null;

    const sc = scalePCsForChordLocal(ch, prev, next);
    const scalePcs = sc.pcs;

    const chordPcs = chordTonesPCs(ch);
    const rootPc = pc(ch.root);

    els.pianoTop.textContent = `${chordName(ch)}  ¬∑  ${noteName(ch.root)} ${sc.mode}`;
    els.pianoHint.textContent = `Scale suggestion: ${noteName(ch.root)} ${sc.mode} (auto-picked from context) ¬∑ chord tones highlighted`;

    drawPiano(scalePcs, chordPcs, rootPc, sc.mode);
  }

  function drawPiano(scalePcs, chordPcs, rootPc, modeName){
    const svg = els.pianoSvg;
    svg.innerHTML = "";

    const marker = state.markerStyle || "dots";

    // build 2 octaves + C (25 white-ish keys in visual)
    const startMidi = 48; // C3
    const endMidi = 84;   // C6 (exclusive-ish for drawing)
    const keys = [];
    for (let m=startMidi;m<=endMidi;m++){
      const p = pc(m);
      const isWhite = WHITE_PCS.has(p);
      keys.push({m,p,isWhite});
    }

    // map white positions
    let whiteIndex = 0;
    for (const k of keys){
      if (k.isWhite){
        k.wx = whiteIndex;
        whiteIndex++;
      }
    }
    const whiteCount = whiteIndex;
    const W = 1000;
    const H = 240;
    const whiteW = W / whiteCount;
    const whiteH = H;
    const blackW = whiteW * 0.62;
    const blackH = H * 0.62;

    // helper: determine if note is in lists
    const inScale = (p)=>scalePcs.includes(pc(p));
    const inChord = (p)=>chordPcs.includes(pc(p));

    // draw white keys
    for (const k of keys){
      if (!k.isWhite) continue;
      const x = k.wx * whiteW;
      const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
      rect.setAttribute("x", x.toFixed(2));
      rect.setAttribute("y", "0");
      rect.setAttribute("width", (whiteW+0.6).toFixed(2));
      rect.setAttribute("height", whiteH.toFixed(2));
      rect.setAttribute("rx", "10");
      rect.setAttribute("ry", "10");

      const isScale = inScale(k.p);
      rect.setAttribute("fill", isScale ? "var(--accent)" : "var(--keyWhite)");

      // fixed thin black outline separating scale keys
      if (isScale){
        rect.setAttribute("stroke", `rgba(0,0,0,var(--scaleStrokeAlpha))`);
        rect.setAttribute("stroke-width", String(parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--scaleStrokeWidth")) || 2.2));
      } else {
        rect.setAttribute("stroke", "var(--keyBorder)");
        rect.setAttribute("stroke-width", "1");
      }
      svg.appendChild(rect);

      // chord/root markers
      const isChord = inChord(k.p);
      const isRoot = (rootPc!=null && k.p===rootPc);
      if (isChord || isRoot){
        addMarker(svg, x + whiteW/2, whiteH*0.80, isRoot ? "root" : "chord", marker);
      }
    }

    // draw black keys (after whites so they appear on top)
    // black keys relative position: between specific whites
    for (const k of keys){
      if (k.isWhite) continue;
      // find nearest left white
      const leftWhite = keys.slice().reverse().find(w => w.isWhite && w.m < k.m);
      if (!leftWhite) continue;
      const x = (leftWhite.wx + 1) * whiteW - (blackW/2);
      const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
      rect.setAttribute("x", x.toFixed(2));
      rect.setAttribute("y", "0");
      rect.setAttribute("width", blackW.toFixed(2));
      rect.setAttribute("height", blackH.toFixed(2));
      rect.setAttribute("rx", "9");
      rect.setAttribute("ry", "9");

      const isScale = inScale(k.p);
      rect.setAttribute("fill", isScale ? "var(--accent)" : "var(--keyBlack)");
      if (isScale){
        rect.setAttribute("stroke", `rgba(0,0,0,var(--scaleStrokeAlpha))`);
        rect.setAttribute("stroke-width", String(parseFloat(getComputedStyle(document.documentElement).getPropertyValue("--scaleStrokeWidth")) || 2.2));
      } else {
        rect.setAttribute("stroke", "var(--keyBlackBorder)");
        rect.setAttribute("stroke-width", "1");
      }
      svg.appendChild(rect);

      const isChord = inChord(k.p);
      const isRoot = (rootPc!=null && k.p===rootPc);
      if (isChord || isRoot){
        addMarker(svg, x + blackW/2, blackH*0.78, isRoot ? "root" : "chord", marker, true);
      }
    }
  }

  function addMarker(svg, cx, cy, kind, style, onBlack=false){
    const color = kind==="root" ? "var(--good)" : "var(--chord)";
    const stroke = "rgba(0,0,0,.35)";
    const size = onBlack ? 9.0 : 10.5;

    if (style==="rings"){
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx", cx.toFixed(2));
      c.setAttribute("cy", cy.toFixed(2));
      c.setAttribute("r", (size*0.72).toFixed(2));
      c.setAttribute("fill", "none");
      c.setAttribute("stroke", color);
      c.setAttribute("stroke-width", "3");
      svg.appendChild(c);
      return;
    }

    if (style==="triangles"){
      const p = document.createElementNS("http://www.w3.org/2000/svg","path");
      const h = size*1.2;
      const d = `M ${cx} ${cy-h/2} L ${cx-size*0.8} ${cy+h/2} L ${cx+size*0.8} ${cy+h/2} Z`;
      p.setAttribute("d", d);
      p.setAttribute("fill", color);
      p.setAttribute("stroke", stroke);
      p.setAttribute("stroke-width", "1.2");
      svg.appendChild(p);
      return;
    }

    if (style==="squares"){
      const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
      const w = size*1.25;
      r.setAttribute("x", (cx-w/2).toFixed(2));
      r.setAttribute("y", (cy-w/2).toFixed(2));
      r.setAttribute("width", w.toFixed(2));
      r.setAttribute("height", w.toFixed(2));
      r.setAttribute("rx", "3");
      r.setAttribute("fill", color);
      r.setAttribute("stroke", stroke);
      r.setAttribute("stroke-width", "1.2");
      svg.appendChild(r);
      return;
    }

    // default dots
    const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
    c.setAttribute("cx", cx.toFixed(2));
    c.setAttribute("cy", cy.toFixed(2));
    c.setAttribute("r", (size*0.55).toFixed(2));
    c.setAttribute("fill", color);
    c.setAttribute("stroke", stroke);
    c.setAttribute("stroke-width", "1.2");
    svg.appendChild(c);
  }

  /* ---------- Render meta/status line ---------- */
  function renderMeta(){
    els.metaBars.textContent = String(state.chartBars.length || state.bars || 0);
    els.metaTempo.textContent = String(state.tempo|0);
    els.metaSwing.textContent = String(state.swing|0);
    els.metaChaos.textContent = String(state.chaos|0);

    const halvesCount = (state.chartBars||[]).filter(b=>b.split).length;
    if (halvesCount>0){
      els.metaHalves.style.display = "";
      els.metaHalvesVal.textContent = String(halvesCount);
    } else {
      els.metaHalves.style.display = "none";
      els.metaHalvesVal.textContent = "0";
    }

    const got = getChordAt(state.activeBar, state.activeHalf);
    els.pillLine.textContent = got?.chord ? `Now: ${chordName(got.chord)}` : "‚Äî";

    // ‚ÄúKey‚Äù display only if generator thinks it's stable
    if (state.showKey){
      els.leadKey.textContent = `Center: ${noteName(state.keyRoot)} ${state.keyMode}`;
    } else {
      els.leadKey.textContent = "Center: ‚Äî";
    }
  }

  function renderAll(){
    renderMeta();
    renderLead();
    renderPianoForActive();
  }

  /* ---------- Copy chart ---------- */
  function chartToText(){
    const bars = state.chartBars || [];
    const parts = bars.map((b, i)=>{
      if (!b.split) return chordName(b.chords[0]);
      return `${chordName(b.chords[0])}, ${chordName(b.chords[1])}`;
    });
    // group into bars with | |
    return `| ${parts.join(" | ")} |`;
  }

  async function copyChart(){
    const txt = chartToText();
    try{
      await navigator.clipboard.writeText(txt);
      els.msg.textContent = "Copied chart to clipboard.";
    }catch{
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      els.msg.textContent = "Copied chart (fallback).";
    }
  }

  /* ---------- Defaults / Randomize All ---------- */
  function setUIFromState(){
    els.bars.value = state.bars; els.barsNum.value = state.bars;
    els.halfChords.checked = !!state.halfEnabled;
    els.halfDensity.value = state.halfDensity; els.halfDensityNum.value = state.halfDensity;
    els.tempo.value = state.tempo; els.tempoNum.value = state.tempo;
    els.swing.value = state.swing; els.swingNum.value = state.swing;
    els.chaos.value = state.chaos; els.chaosNum.value = state.chaos;
    els.rootMode.value = state.rootMode;

    els.grooveStyle.value = state.grooveStyle;
    els.compStyle.value = state.compStyle;
    els.bassPreset.value = state.bassPreset;
    els.keysPreset.value = state.keysPreset;
    els.drumsPreset.value = state.drumsPreset;

    els.drumsLevel.value = state.drumsLevel; els.drumsLevelNum.value = state.drumsLevel;

    els.keysComplex.value = state.keysComplex; els.keysComplexNum.value = state.keysComplex;
    els.keysFill.value = state.keysFill; els.keysFillNum.value = state.keysFill;

    els.bassComplex.value = state.bassComplex; els.bassComplexNum.value = state.bassComplex;
    els.bassFill.value = state.bassFill; els.bassFillNum.value = state.bassFill;

    els.drumsComplex.value = state.drumsComplex; els.drumsComplexNum.value = state.drumsComplex;
    els.drumsFill.value = state.drumsFill; els.drumsFillNum.value = state.drumsFill;

    els.genrePreset.value = state.genrePreset;
    els.progressionLogic.value = state.progressionLogic;

    // themes
    els.pageTheme.value = state.pageTheme;
    els.pianoTheme.value = state.pianoTheme;
    els.markerStyle.value = state.markerStyle;

    // limiter checkboxes
    setChordLimiterState(state.limiter);
  }

  function resetDefaults(){
    state = JSON.parse(JSON.stringify({
      ...state,
      bars: DEFAULTS.bars,
      halfEnabled: DEFAULTS.halfEnabled,
      halfDensity: DEFAULTS.halfDensity,
      tempo: DEFAULTS.tempo,
      swing: DEFAULTS.swing,
      chaos: DEFAULTS.chaos,
      rootMode: DEFAULTS.rootMode,
      progressionLogic: DEFAULTS.progressionLogic,
      genrePreset: DEFAULTS.genrePreset,
      grooveStyle: DEFAULTS.grooveStyle,
      compStyle: DEFAULTS.compStyle,
      bassPreset: DEFAULTS.bassPreset,
      keysPreset: DEFAULTS.keysPreset,
      drumsPreset: DEFAULTS.drumsPreset,
      drumsLevel: DEFAULTS.drumsLevel,
      keysComplex: DEFAULTS.keysComplex,
      keysFill: DEFAULTS.keysFill,
      bassComplex: DEFAULTS.bassComplex,
      bassFill: DEFAULTS.bassFill,
      drumsComplex: DEFAULTS.drumsComplex,
      drumsFill: DEFAULTS.drumsFill,
      pageTheme: DEFAULTS.pageTheme,
      pianoTheme: DEFAULTS.pianoTheme,
      markerStyle: DEFAULTS.markerStyle,
      limiter: {...DEFAULTS.limiter},
      weights: macroToWeights(DEFAULTS.chaos),
      activeBar: 0,
      activeHalf: 0,
    }));

    applyPageTheme(state.pageTheme);
    applyPianoTheme(state.pianoTheme);

    setUIFromState();

    // regenerate (default generator, not a song shape)
    els.songSelect.value = "none";
    generateChart();
    els.msg.textContent = "Reset to defaults.";
  }

  function randomizeAll(){
    // random within sensible ranges
    const gp = GENRE_PRESETS[pick(Object.keys(GENRE_PRESETS))];
    applyGenrePresetById(Object.keys(GENRE_PRESETS).find(k=>GENRE_PRESETS[k]===gp) || "jazzSwing");

    // chaos + modes
    state.chaos = rint(0, 85);
    state.rootMode = pick(["keyed","drifting","orbiting","freefall"]);
    state.progressionLogic = pick(Object.keys(PROGRESSION_LOGICS));
    state.weights = macroToWeights(state.chaos);

    // bars + halves
    state.bars = rint(2, 16);
    state.halfEnabled = chance(0.65);
    state.halfDensity = rint(0, 70);

    // sounds
    state.keysPreset = pick(["piano","ep","organ","pad","fm","chip","bell","glass","pluck2","vibes","choirPad","noisePad","guitarish","clavBright"]);
    state.bassPreset = pick(["upright","round","sub","pluck","fmBass","rubber","acid","reese","squareBass","wobble","pickBass","muted"]);
    state.drumsPreset = pick(["jazz","brushes","tight","rock","disco","lofi","minimal","electro","house","trap","perc","dnb","techno"]);

    // groove + comp
    state.grooveStyle = pick(Array.from(els.grooveStyle.options).map(o=>o.value));
    state.compStyle = pick(Array.from(els.compStyle.options).map(o=>o.value));

    // feel
    state.tempo = rint(60, 220);
    state.swing = rint(50, 72);

    state.keysComplex = rint(10, 95);
    state.keysFill = rint(0, 85);
    state.bassComplex = rint(10, 95);
    state.bassFill = rint(0, 70);
    state.drumsComplex = rint(10, 95);
    state.drumsFill = rint(0, 90);
    state.drumsLevel = rint(20, 85);

    // limiters random-ish but keep at least some core qualities
    const lim = {...DEFAULTS.limiter};
    lim.qMaj7 = chance(0.85);
    lim.qMin7 = chance(0.85);
    lim.qDom7 = chance(0.85);
    lim.qDim7 = chance(0.35);
    lim.qHalfDim = chance(0.45);
    lim.qSus = chance(0.25);
    lim.qMinMaj = chance(0.20);

    lim.x9 = chance(0.55);
    lim.x11 = chance(0.35);
    lim.x13 = chance(0.35);
    lim.x6 = chance(0.30);
    lim.xAdd9 = chance(0.20);
    lim.xSharp11 = chance(0.20);
    lim.xMin11 = chance(0.25);

    lim.tAlt = chance(0.35);
    lim.tSlash = chance(0.30);
    lim.tChrom = chance(0.35);
    lim.tB9 = chance(0.25);
    lim.tSharp9 = chance(0.25);

    // ensure at least one
    if (!lim.qMaj7 && !lim.qMin7 && !lim.qDom7 && !lim.qDim7 && !lim.qHalfDim && !lim.qSus && !lim.qMinMaj){
      lim.qDom7 = true;
    }
    state.limiter = lim;

    // themes
    state.pageTheme = pick(Object.keys(PAGE_THEMES));
    state.pianoTheme = pick(Object.keys(PIANO_THEMES));
    state.markerStyle = pick(["dots","rings","triangles","squares"]);

    applyPageTheme(state.pageTheme);
    applyPianoTheme(state.pianoTheme);

    // UI + generate
    setUIFromState();
    els.songSelect.value = "none";
    generateChart();

    els.msg.textContent = "Randomized everything üé≤";
  }

  /* ---------- Generate chart (generator mode) ---------- */
  function generateChart(){
    state.weights = macroToWeights(state.chaos);
    // apply progression logic modifier
    const logicId = els.progressionLogic.value || state.progressionLogic || "none";
    const baseW = macroToWeights(state.chaos);
    const logic = PROGRESSION_LOGICS[logicId] || PROGRESSION_LOGICS.none;
    state.weights = logic.apply(baseW, state.chaos);

    const limiter = getChordLimiterState();
    state.limiter = limiter;

    const res = genChartBars({
      bars: state.bars,
      chaos: state.chaos,
      rootMode: state.rootMode,
      weights: state.weights,
      limiter,
      halfEnabled: state.halfEnabled,
      halfDensity: state.halfDensity,
      progressionLogic: logicId,
    });

    state.chartBars = res.bars;
    state.keyRoot = res.keyRoot;
    state.keyMode = res.keyMode;
    state.showKey = res.showKey;

    state.activeBar = 0;
    state.activeHalf = 0;

    player.setTempo(state.tempo, state.swing);
    player.setChart(state.chartBars);

    renderAll();
  }

  /* ---------- Presets selection ---------- */
  function applyGenrePresetById(id){
    const p = GENRE_PRESETS[id];
    if (!p) return;

    state.genrePreset = id;
    state.grooveStyle = p.groove;
    state.compStyle = p.comp;

    state.bassPreset = p.bass;
    state.keysPreset = p.keys;
    state.drumsPreset = p.drums;

    state.keysComplex = p.kC; state.keysFill = p.kF;
    state.bassComplex = p.bC; state.bassFill = p.bF;
    state.drumsComplex = p.dC; state.drumsFill = p.dF;

    state.halfEnabled = p.halfOn;
    state.halfDensity = rint(p.halfDen[0], p.halfDen[1]);

    state.tempo = rint(p.tempo[0], p.tempo[1]);
    state.swing = rint(p.swing[0], p.swing[1]);

    state.progressionLogic = p.logic;

    player.setTempo(state.tempo, state.swing);

    setUIFromState();
    els.msg.textContent = `Preset: ${p.name}`;
  }

  /* ---------- Advanced modal: reorder menus ---------- */
  const MENU_IDS = ["cardControls","cardLimiters","cardLead","cardPiano"];
  const MENU_LABELS = {
    cardControls:"Controls",
    cardLimiters:"Chord limiters",
    cardLead:"Lead sheet",
    cardPiano:"Piano",
  };

  function getMenuOrder(){
    // try localStorage
    try{
      const raw = localStorage.getItem("fm_menu_order");
      if (raw){
        const arr = JSON.parse(raw);
        if (Array.isArray(arr) && arr.every(id=>MENU_IDS.includes(id))){
          // ensure all included
          const full = [...new Set([...arr, ...MENU_IDS])].filter(id=>MENU_IDS.includes(id));
          return full;
        }
      }
    }catch{}
    return MENU_IDS.slice();
  }

  function setMenuOrder(order){
    const app = document.querySelector(".app");
    const header = app.querySelector(".header");
    const cards = order.map(id=>document.getElementById(id)).filter(Boolean);
    // keep header on top, then cards
    cards.forEach(c=>app.appendChild(c));
    app.insertBefore(header, app.firstChild);

    try{ localStorage.setItem("fm_menu_order", JSON.stringify(order)); }catch{}
    renderOrderList(order);
  }

  function renderOrderList(order){
    els.orderList.innerHTML = "";
    order.forEach((id, idx)=>{
      const row = document.createElement("div");
      row.className = "modalRow";

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = MENU_LABELS[id] || id;

      const btns = document.createElement("div");
      btns.className = "reorderBtns";

      const up = document.createElement("button");
      up.className = "btn tiny";
      up.textContent = "‚Üë";
      up.disabled = idx===0;
      up.addEventListener("click", ()=>{
        const n = order.slice();
        [n[idx-1], n[idx]] = [n[idx], n[idx-1]];
        setMenuOrder(n);
      });

      const dn = document.createElement("button");
      dn.className = "btn tiny";
      dn.textContent = "‚Üì";
      dn.disabled = idx===order.length-1;
      dn.addEventListener("click", ()=>{
        const n = order.slice();
        [n[idx], n[idx+1]] = [n[idx+1], n[idx]];
        setMenuOrder(n);
      });

      btns.appendChild(up);
      btns.appendChild(dn);

      row.appendChild(name);
      row.appendChild(btns);
      els.orderList.appendChild(row);
    });
  }

  function openAdv(){ els.advBack.style.display = "flex"; }
  function closeAdv(){ els.advBack.style.display = "none"; }

  /* ---------- Wire up controls (range <-> number) ---------- */
  function bindRangeNumber(rangeEl, numEl, onChange){
    const sync = (v)=>{
      rangeEl.value = v;
      numEl.value = v;
      onChange(Number(v));
    };
    rangeEl.addEventListener("input", ()=> sync(rangeEl.value));
    numEl.addEventListener("change", ()=> sync(numEl.value));
  }

  /* ---------- Init selects ---------- */
  function initSelects(){
    // songSelect
    els.songSelect.innerHTML = "";
    Object.keys(SONG_LIBRARY).forEach(id=>{
      const s = SONG_LIBRARY[id];
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = s.title;
      els.songSelect.appendChild(opt);
    });
    els.songSelect.value = "none";

    // genre preset
    els.genrePreset.innerHTML = "";
    Object.keys(GENRE_PRESETS).forEach(id=>{
      const p = GENRE_PRESETS[id];
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = p.name;
      els.genrePreset.appendChild(opt);
    });

    // progression logic
    els.progressionLogic.innerHTML = "";
    Object.keys(PROGRESSION_LOGICS).forEach(id=>{
      const p = PROGRESSION_LOGICS[id];
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = p.name;
      els.progressionLogic.appendChild(opt);
    });

    // themes
    els.pageTheme.innerHTML = "";
    Object.keys(PAGE_THEMES).forEach(id=>{
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = PAGE_THEMES[id].name;
      els.pageTheme.appendChild(opt);
    });

    els.pianoTheme.innerHTML = "";
    Object.keys(PIANO_THEMES).forEach(id=>{
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = PIANO_THEMES[id].name;
      els.pianoTheme.appendChild(opt);
    });
  }

  /* ---------- Persist/load minimal settings ---------- */
  function loadPersisted(){
    try{
      const pt = localStorage.getItem("fm_page_theme");
      if (pt && PAGE_THEMES[pt]) state.pageTheme = pt;
    }catch{}
    try{
      const kt = localStorage.getItem("fm_piano_theme");
      if (kt && PIANO_THEMES[kt]) state.pianoTheme = kt;
    }catch{}
    try{
      const ms = localStorage.getItem("fm_marker_style");
      if (ms) state.markerStyle = ms;
    }catch{}
    applyPageTheme(state.pageTheme);
    applyPianoTheme(state.pianoTheme);
  }

  function persistMarkerStyle(){
    try{ localStorage.setItem("fm_marker_style", state.markerStyle); }catch{}
  }

  /* ---------- Events ---------- */
  function wireEvents(){
    // top buttons
    els.btnCopy.addEventListener("click", copyChart);
    els.btnDefaults.addEventListener("click", resetDefaults);
    els.btnDefaults2.addEventListener("click", resetDefaults);

    els.btnPlay.addEventListener("click", async ()=>{
      if (!state.chartBars.length) generateChart();

      if (!player.isPlaying){
        player.setTempo(state.tempo, state.swing);
        player.setChart(state.chartBars);
        player.jumpTo(state.activeBar, state.activeHalf);
        await player.start();
        els.btnPlay.textContent = "‚è∏";
        els.btnPlay.title = "Pause";
        els.msg.textContent = "Playing. Tap bars to jump (and audition works too).";
      } else {
        player.stop();
        els.btnPlay.textContent = "‚ñ∂Ô∏è";
        els.btnPlay.title = "Play";
        els.msg.textContent = "Paused. Tap bars to audition + focus.";
        // IMPORTANT: audition still works because audio engine is independent of transport.
      }
    });

    els.btnGenerate.addEventListener("click", ()=>{
      els.songSelect.value = "none";
      generateChart();
      els.msg.textContent = "Generated üé∞";
    });

    els.btnRandomAll.addEventListener("click", randomizeAll);

    // sliders / numbers
    bindRangeNumber(els.bars, els.barsNum, (v)=>{
      state.bars = clamp(v|0, 2, 16);
      els.metaBars.textContent = String(state.bars);
    });

    els.halfChords.addEventListener("change", ()=>{
      state.halfEnabled = !!els.halfChords.checked;
    });
    bindRangeNumber(els.halfDensity, els.halfDensityNum, (v)=>{
      state.halfDensity = clamp(v|0, 0, 100);
    });

    bindRangeNumber(els.tempo, els.tempoNum, (v)=>{
      state.tempo = clamp(v|0, 40, 300);
      player.setTempo(state.tempo, state.swing);
      renderMeta();
    });

    bindRangeNumber(els.swing, els.swingNum, (v)=>{
      state.swing = clamp(v|0, 50, 80);
      player.setTempo(state.tempo, state.swing);
      renderMeta();
    });

    bindRangeNumber(els.chaos, els.chaosNum, (v)=>{
      state.chaos = clamp(v|0, 0, 100);
      renderMeta();
    });

    els.rootMode.addEventListener("change", ()=>{
      state.rootMode = els.rootMode.value;
    });

    els.grooveStyle.addEventListener("change", ()=>{
      state.grooveStyle = els.grooveStyle.value;
    });

    els.compStyle.addEventListener("change", ()=>{
      state.compStyle = els.compStyle.value;
    });

    els.bassPreset.addEventListener("change", ()=>{
      state.bassPreset = els.bassPreset.value;
      player.refreshVoices();
    });
    els.keysPreset.addEventListener("change", ()=>{
      state.keysPreset = els.keysPreset.value;
      player.refreshVoices();
    });
    els.drumsPreset.addEventListener("change", ()=>{
      state.drumsPreset = els.drumsPreset.value;
      player.refreshVoices();
    });

    bindRangeNumber(els.drumsLevel, els.drumsLevelNum, (v)=>{
      state.drumsLevel = clamp(v|0, 0, 100);
    });

    bindRangeNumber(els.keysComplex, els.keysComplexNum, (v)=> state.keysComplex = clamp(v|0, 0, 100));
    bindRangeNumber(els.keysFill, els.keysFillNum, (v)=> state.keysFill = clamp(v|0, 0, 100));

    bindRangeNumber(els.bassComplex, els.bassComplexNum, (v)=> state.bassComplex = clamp(v|0, 0, 100));
    bindRangeNumber(els.bassFill, els.bassFillNum, (v)=> state.bassFill = clamp(v|0, 0, 100));

    bindRangeNumber(els.drumsComplex, els.drumsComplexNum, (v)=> state.drumsComplex = clamp(v|0, 0, 100));
    bindRangeNumber(els.drumsFill, els.drumsFillNum, (v)=> state.drumsFill = clamp(v|0, 0, 100));

    // limiters regenerate hint
    const limiterBoxes = document.querySelectorAll("#cardLimiters input[type='checkbox']");
    limiterBoxes.forEach(cb=>{
      cb.addEventListener("change", ()=>{
        state.limiter = getChordLimiterState();
      });
    });

    // genre preset
    els.genrePreset.addEventListener("change", ()=>{
      const id = els.genrePreset.value;
      applyGenrePresetById(id);
      // keep UI selection
      state.genrePreset = id;
      state.progressionLogic = GENRE_PRESETS[id]?.logic || state.progressionLogic;
      els.progressionLogic.value = state.progressionLogic;
      // do not auto-generate; user can Generate
      renderMeta();
    });

    // progression logic
    els.progressionLogic.addEventListener("change", ()=>{
      state.progressionLogic = els.progressionLogic.value;
    });

    // song shapes
    els.songSelect.addEventListener("change", ()=>{
      const id = els.songSelect.value;
      if (id==="none") return;
      // ensure we have a key root (generate once if empty)
      if (!state.chartBars.length){
        generateChart();
      }
      loadSongById(id);
    });

    // advanced modal
    els.btnGear.addEventListener("click", openAdv);
    els.btnCloseAdv.addEventListener("click", closeAdv);
    els.advBack.addEventListener("click", (e)=>{
      if (e.target === els.advBack) closeAdv();
    });
    els.btnResetMenu.addEventListener("click", ()=>{
      setMenuOrder(MENU_IDS.slice());
      els.msg.textContent = "Menu order reset.";
    });

    els.pageTheme.addEventListener("change", ()=>{
      const id = els.pageTheme.value;
      applyPageTheme(id);
    });

    els.pianoTheme.addEventListener("change", ()=>{
      const id = els.pianoTheme.value;
      applyPianoTheme(id);
      renderPianoForActive();
    });

    els.markerStyle.addEventListener("change", ()=>{
      state.markerStyle = els.markerStyle.value;
      persistMarkerStyle();
      renderPianoForActive();
    });

    // helpful: spacebar play/pause
    window.addEventListener("keydown",(e)=>{
      if (e.code==="Space"){
        e.preventDefault();
        els.btnPlay.click();
      }
    }, {passive:false});
  }

  /* ---------- Boot ---------- */
  function boot(){
    initSelects();
    loadPersisted();

    // init UI default selections
    els.genrePreset.value = DEFAULTS.genrePreset;
    els.progressionLogic.value = DEFAULTS.progressionLogic;

    // restore marker style if saved
    try{
      const ms = localStorage.getItem("fm_marker_style");
      if (ms) state.markerStyle = ms;
    }catch{}
    els.markerStyle.value = state.markerStyle;

    // restore menu order
    const order = getMenuOrder();
    setMenuOrder(order);

    // set up UI from defaults
    state.limiter = {...DEFAULTS.limiter};
    setChordLimiterState(state.limiter);
    state.pageTheme = state.pageTheme || DEFAULTS.pageTheme;
    state.pianoTheme = state.pianoTheme || DEFAULTS.pianoTheme;

    applyPageTheme(state.pageTheme);
    applyPianoTheme(state.pianoTheme);

    setUIFromState();
    wireEvents();

    // first chart
    generateChart();
    player.setTempo(state.tempo, state.swing);
    player.setChart(state.chartBars);

    els.msg.textContent = "Ready. Tap a bar to audition. Generate üé∞ for new charts. ‚öôÔ∏è for menu order + themes.";
  }

  boot();
</script>

</body>
</html>
